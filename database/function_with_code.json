[
    {
      "schema": "auth",
      "function_name": "email",
      "definition": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
    },
    {
      "schema": "auth",
      "function_name": "jwt",
      "definition": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
    },
    {
      "schema": "auth",
      "function_name": "role",
      "definition": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
    },
    {
      "schema": "auth",
      "function_name": "uid",
      "definition": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "armor",
      "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "armor",
      "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "crypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "dearmor",
      "definition": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "decrypt_iv",
      "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "digest",
      "definition": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "digest",
      "definition": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "encrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "encrypt_iv",
      "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "gen_random_bytes",
      "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "gen_random_uuid",
      "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "gen_salt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "gen_salt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "grant_pg_cron_access",
      "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "grant_pg_graphql_access",
      "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "grant_pg_net_access",
      "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "hmac",
      "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "hmac",
      "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pg_stat_statements",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pg_stat_statements_info",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pg_stat_statements_reset",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)\n RETURNS timestamp with time zone\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_armor_headers",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_key_id",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_decrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_encrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_encrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_encrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_pub_encrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_decrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_decrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_encrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_encrypt",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_encrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgp_sym_encrypt_bytea",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgrst_ddl_watch",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "pgrst_drop_watch",
      "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "set_graphql_placeholder",
      "definition": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_generate_v1",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_generate_v1mc",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_generate_v3",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_generate_v4",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_generate_v5",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_nil",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_ns_dns",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_ns_oid",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_ns_url",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
    },
    {
      "schema": "extensions",
      "function_name": "uuid_ns_x500",
      "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "_internal_resolve",
      "definition": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "comment_directive",
      "definition": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "exception",
      "definition": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "get_schema_version",
      "definition": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "increment_schema_version",
      "definition": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
    },
    {
      "schema": "graphql",
      "function_name": "resolve",
      "definition": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
    },
    {
      "schema": "graphql_public",
      "function_name": "graphql",
      "definition": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
    },
    {
      "schema": "pgbouncer",
      "function_name": "get_auth",
      "definition": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "activate_membership",
      "definition": "CREATE OR REPLACE FUNCTION public.activate_membership(p_user_id uuid, p_plan_id text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    expiry_date TIMESTAMP WITH TIME ZONE;\n    result JSON;\nBEGIN\n    -- Calculate expiry date (default 1 month)\n    expiry_date := NOW() + INTERVAL '1 month';\n    \n    -- Update user profile\n    UPDATE public.user_profiles \n    SET \n        membership_plan = p_plan_id,\n        membership_expiry = expiry_date,\n        updated_at = NOW()\n    WHERE id = p_user_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'User profile not found'\n        );\n    END IF;\n    \n    RETURN json_build_object(\n        'success', true,\n        'user_id', p_user_id,\n        'plan_id', p_plan_id,\n        'expiry_date', expiry_date\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "admin_verify_payment",
      "definition": "CREATE OR REPLACE FUNCTION public.admin_verify_payment(p_payment_id text, p_admin_notes text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    payment_record RECORD;\nBEGIN\n    -- Check if payment exists and is in paid or disputed status\n    SELECT * INTO payment_record\n    FROM public.payments\n    WHERE payment_id = p_payment_id \n        AND status IN ('paid', 'disputed');\n    \n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment not found or not in verifiable status'\n        );\n    END IF;\n    \n    -- Mark payment as verified by admin\n    UPDATE public.payments\n    SET status = 'verified',\n        verification_status = 'verified',\n        verified_at = NOW(),\n        admin_notes = p_admin_notes\n    WHERE id = payment_record.id;\n    \n    -- Record admin verification\n    INSERT INTO public.payment_verifications (\n        payment_id, reference_id, verification_attempt, status, verification_method, verified_at, admin_notes\n    ) VALUES (\n        payment_record.id, payment_record.payment_reference, 1, 'verified', 'admin', NOW(), p_admin_notes\n    );\n    \n    -- Activate user membership\n    UPDATE public.user_profiles\n    SET membership_plan = payment_record.plan_id,\n        membership_expiry = CASE \n            WHEN payment_record.plan_id = 'monthly' THEN NOW() + INTERVAL '1 month'\n            WHEN payment_record.plan_id = 'yearly' THEN NOW() + INTERVAL '1 year'\n            WHEN payment_record.plan_id = 'lifetime' THEN NOW() + INTERVAL '100 years'\n            ELSE NOW() + INTERVAL '1 month'\n        END,\n        updated_at = NOW()\n    WHERE id = payment_record.user_id;\n    \n    -- Log admin verification\n    INSERT INTO public.payment_audit_log (\n        payment_id, action, old_status, new_status, reason, performed_by\n    ) VALUES (\n        payment_record.id, 'verified', payment_record.status, 'verified', 'Admin manual verification', auth.uid()\n    );\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Payment verified by admin',\n        'payment_id', payment_record.payment_id,\n        'plan_name', payment_record.plan_name\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "calculate_exam_ranks",
      "definition": "CREATE OR REPLACE FUNCTION public.calculate_exam_ranks(exam_name character varying)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  UPDATE exam_stats \n  SET rank = ranked.rank\n  FROM (\n    SELECT \n      id,\n      ROW_NUMBER() OVER (ORDER BY best_score DESC, average_score DESC, total_tests DESC) as rank\n    FROM exam_stats \n    WHERE exam_id = exam_name\n  ) ranked\n  WHERE exam_stats.id = ranked.id AND exam_stats.exam_id = exam_name;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "calculate_exam_ranks",
      "definition": "CREATE OR REPLACE FUNCTION public.calculate_exam_ranks(exam_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    WITH ranked_stats AS (\n        SELECT \n            id,\n            ROW_NUMBER() OVER (ORDER BY best_score DESC, average_score DESC, total_tests DESC) as new_rank\n        FROM public.exam_stats\n        WHERE exam_id = exam_name\n    )\n    UPDATE public.exam_stats\n    SET rank = ranked_stats.new_rank\n    FROM ranked_stats\n    WHERE public.exam_stats.id = ranked_stats.id;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "calculate_test_rank",
      "definition": "CREATE OR REPLACE FUNCTION public.calculate_test_rank(user_uuid uuid, exam_name text, test_type_name text, test_name text)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_rank INTEGER;\n    total_participants INTEGER;\nBEGIN\n    -- Calculate rank based on score\n    WITH ranked_scores AS (\n        SELECT \n            user_id,\n            ROW_NUMBER() OVER (ORDER BY score DESC, completed_at ASC) as rank,\n            COUNT(*) OVER () as total_count\n        FROM public.individual_test_scores\n        WHERE exam_id = exam_name\n            AND test_type = test_type_name\n            AND test_id = test_name\n    )\n    SELECT rank, total_count\n    INTO user_rank, total_participants\n    FROM ranked_scores\n    WHERE user_id = user_uuid;\n\n    -- Update the individual test score record with rank\n    UPDATE public.individual_test_scores\n    SET rank = user_rank,\n        total_participants = total_participants,\n        updated_at = NOW()\n    WHERE user_id = user_uuid\n        AND exam_id = exam_name\n        AND test_type = test_type_name\n        AND test_id = test_name;\n\n    RETURN user_rank;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "check_availability",
      "definition": "CREATE OR REPLACE FUNCTION public.check_availability(p_email text, p_phone text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    email_exists BOOLEAN;\n    phone_exists BOOLEAN;\n    result JSON;\nBEGIN\n    -- Check email availability in both auth.users and user_profiles\n    SELECT EXISTS(\n        SELECT 1 FROM auth.users WHERE email = p_email\n        UNION\n        SELECT 1 FROM public.user_profiles WHERE email = p_email\n    ) INTO email_exists;\n    \n    -- Check phone availability (if provided)\n    IF p_phone IS NOT NULL THEN\n        SELECT EXISTS(SELECT 1 FROM public.user_profiles WHERE phone = p_phone) INTO phone_exists;\n    ELSE\n        phone_exists := FALSE;\n    END IF;\n    \n    result := json_build_object(\n        'email_available', NOT email_exists,\n        'phone_available', NOT phone_exists,\n        'email_exists', email_exists,\n        'phone_exists', phone_exists\n    );\n    \n    RETURN result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "check_email_uniqueness",
      "definition": "CREATE OR REPLACE FUNCTION public.check_email_uniqueness(p_email text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    email_count INTEGER;\nBEGIN\n    -- Check in user_profiles table\n    SELECT COUNT(*) INTO email_count\n    FROM public.user_profiles\n    WHERE email = p_email;\n    \n    -- If found in user_profiles, it's not unique\n    IF email_count > 0 THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check in auth.users table\n    SELECT COUNT(*) INTO email_count\n    FROM auth.users\n    WHERE email = p_email;\n    \n    -- If found in auth.users, it's not unique\n    IF email_count > 0 THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- If not found in either table, it's unique\n    RETURN TRUE;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "check_phone_uniqueness",
      "definition": "CREATE OR REPLACE FUNCTION public.check_phone_uniqueness(p_phone text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    phone_count INTEGER;\nBEGIN\n    -- Check in user_profiles table\n    SELECT COUNT(*) INTO phone_count\n    FROM public.user_profiles\n    WHERE phone = p_phone;\n    \n    -- If found in user_profiles, it's not unique\n    IF phone_count > 0 THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check in auth.users table\n    SELECT COUNT(*) INTO phone_count\n    FROM auth.users\n    WHERE phone = p_phone;\n    \n    -- If found in auth.users, it's not unique\n    IF phone_count > 0 THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- If not found in either table, it's unique\n    RETURN TRUE;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "cleanup_expired_otps",
      "definition": "CREATE OR REPLACE FUNCTION public.cleanup_expired_otps()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM public.otp_verifications\n    WHERE expires_at < NOW() - INTERVAL '1 hour';\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "cleanup_expired_payments",
      "definition": "CREATE OR REPLACE FUNCTION public.cleanup_expired_payments()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    expired_count INTEGER;\nBEGIN\n    -- Mark expired payments as expired\n    UPDATE public.payments\n    SET status = 'expired'\n    WHERE status = 'pending' \n        AND expires_at < NOW();\n    \n    GET DIAGNOSTICS expired_count = ROW_COUNT;\n    \n    -- Log expired payments\n    INSERT INTO public.payment_audit_log (payment_id, action, old_status, new_status, reason)\n    SELECT id, 'expired', 'pending', 'expired', 'Payment expired'\n    FROM public.payments\n    WHERE status = 'expired' \n        AND expires_at < NOW();\n    \n    RETURN expired_count;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_all_default_exam_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.create_all_default_exam_stats(p_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Create default stats for all exam types\n  INSERT INTO exam_stats (user_id, exam_id, total_tests, best_score, average_score, rank)\n  VALUES \n    (p_user_id, 'ssc-cgl', 0, 0, 0, 0),\n    (p_user_id, 'ssc-mts', 0, 0, 0, 0),\n    (p_user_id, 'bank-po', 0, 0, 0, 0),\n    (p_user_id, 'railway', 0, 0, 0, 0),\n    (p_user_id, 'airforce', 0, 0, 0, 0)\n  ON CONFLICT (user_id, exam_id) DO NOTHING;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_default_exam_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.create_default_exam_stats(p_user_id uuid, p_exam_id text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  INSERT INTO exam_stats (user_id, exam_id, total_tests, best_score, average_score, rank)\n  VALUES (p_user_id, p_exam_id, 0, 0, 0, 0)\n  ON CONFLICT (user_id, exam_id) DO NOTHING;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_membership_plan",
      "definition": "CREATE OR REPLACE FUNCTION public.create_membership_plan(p_id text, p_name text, p_description text, p_price numeric, p_duration_months integer, p_features jsonb DEFAULT '[]'::jsonb, p_display_order integer DEFAULT 0)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    new_plan RECORD;\nBEGIN\n    INSERT INTO public.membership_plans (\n        id, name, description, price, duration_months, features, display_order\n    ) VALUES (\n        p_id, p_name, p_description, p_price, p_duration_months, p_features, p_display_order\n    ) RETURNING * INTO new_plan;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'plan_id', new_plan.id,\n        'name', new_plan.name,\n        'price', new_plan.price,\n        'message', 'Plan created successfully'\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_payment",
      "definition": "CREATE OR REPLACE FUNCTION public.create_payment(p_user_id uuid, p_payment_id text, p_plan_id text, p_plan_name text, p_amount numeric, p_payment_method text, p_upi_id text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    new_payment RECORD;\nBEGIN\n    -- Insert payment record\n    INSERT INTO public.payments (\n        user_id, payment_id, plan_id, plan_name, amount, payment_method, upi_id\n    ) VALUES (\n        p_user_id, p_payment_id, p_plan_id, p_plan_name, p_amount, p_payment_method, p_upi_id\n    ) RETURNING * INTO new_payment;\n    \n    -- Log the creation\n    INSERT INTO public.payment_audit_log (\n        payment_id, action, new_status, reason\n    ) VALUES (\n        new_payment.id, 'created', 'pending', 'Payment created'\n    );\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'payment_id', new_payment.payment_id,\n        'amount', new_payment.amount,\n        'plan_name', new_payment.plan_name,\n        'expires_at', new_payment.expires_at\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_referral_mapping",
      "definition": "CREATE OR REPLACE FUNCTION public.create_referral_mapping(referred_user_id uuid, referral_code character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_referrer_id UUID;\n    v_result JSONB;\nBEGIN\n    -- Find the referrer by referral code\n    SELECT id INTO v_referrer_id\n    FROM public.user_profiles\n    WHERE referral_code = create_referral_mapping.referral_code;\n    \n    IF v_referrer_id IS NULL THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'Invalid referral code'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Check if user is trying to refer themselves\n    IF v_referrer_id = referred_user_id THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'Cannot refer yourself'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Check if user is already referred\n    IF EXISTS (SELECT 1 FROM public.referral_mappings WHERE referred_id = referred_user_id) THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'User is already referred'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Create referral mapping\n    INSERT INTO public.referral_mappings (referrer_id, referred_id, referral_code)\n    VALUES (v_referrer_id, referred_user_id, referral_code);\n    \n    -- Log the transaction\n    INSERT INTO public.referral_transactions (referrer_id, referred_id, transaction_type, amount, referral_code)\n    VALUES (v_referrer_id, referred_user_id, 'signup', 0.00, referral_code);\n    \n    v_result := jsonb_build_object(\n        'success', true,\n        'message', 'Referral mapping created successfully',\n        'referrer_id', v_referrer_id\n    );\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_referral_tracking",
      "definition": "CREATE OR REPLACE FUNCTION public.create_referral_tracking(referrer_user_id uuid, referred_user_id uuid, referral_code_input character varying)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    tracking_id UUID;\n    referrer_code VARCHAR(20);\n    result JSON;\nBEGIN\n    -- Validate referral code\n    SELECT referral_code INTO referrer_code \n    FROM user_profiles \n    WHERE id = referrer_user_id AND referral_code = referral_code_input;\n    \n    IF referrer_code IS NULL THEN\n        RETURN json_build_object('success', false, 'message', 'Invalid referral code');\n    END IF;\n    \n    -- Check if user is trying to refer themselves\n    IF referrer_user_id = referred_user_id THEN\n        RETURN json_build_object('success', false, 'message', 'Cannot refer yourself');\n    END IF;\n    \n    -- Check if user already has a referrer\n    IF EXISTS (SELECT 1 FROM user_profiles WHERE id = referred_user_id AND referred_by IS NOT NULL) THEN\n        RETURN json_build_object('success', false, 'message', 'User already has a referrer');\n    END IF;\n    \n    -- Check referrer's limit\n    IF EXISTS (\n        SELECT 1 FROM user_profiles \n        WHERE id = referrer_user_id \n        AND total_referrals >= max_referrals\n    ) THEN\n        RETURN json_build_object('success', false, 'message', 'Referrer has reached maximum referrals');\n    END IF;\n    \n    -- Create tracking record\n    INSERT INTO referral_tracking (\n        referrer_id, referred_id, referral_code, referral_link\n    ) VALUES (\n        referrer_user_id, referred_user_id, referral_code_input,\n        'https://yourapp.com/signup?ref=' || referral_code_input\n    ) RETURNING id INTO tracking_id;\n    \n    -- Update referred user's profile\n    UPDATE user_profiles \n    SET referred_by = referrer_user_id,\n        updated_at = NOW()\n    WHERE id = referred_user_id;\n    \n    -- Update referrer's total count\n    UPDATE user_profiles \n    SET total_referrals = total_referrals + 1,\n        updated_at = NOW()\n    WHERE id = referrer_user_id;\n    \n    -- Log event\n    INSERT INTO referral_events (event_type, referrer_id, referred_id, tracking_id, event_data)\n    VALUES ('referral_signup', referrer_user_id, referred_user_id, tracking_id, \n            json_build_object('referral_code', referral_code_input));\n    \n    RETURN json_build_object(\n        'success', true, \n        'message', 'Referral tracking created successfully',\n        'tracking_id', tracking_id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_user_profile_after_otp",
      "definition": "CREATE OR REPLACE FUNCTION public.create_user_profile_after_otp(p_email text, p_verification_id uuid, p_phone text DEFAULT NULL::text, p_name text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    user_id UUID;\n    otp_record RECORD;\n    result JSON;\nBEGIN\n    -- Verify that OTP was actually verified\n    SELECT * INTO otp_record\n    FROM public.otp_verifications\n    WHERE id = p_verification_id\n    AND email = p_email\n    AND is_verified = TRUE;\n    \n    IF NOT FOUND THEN\n        result := json_build_object(\n            'success', false,\n            'message', 'OTP verification not found or not verified'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Get user ID from auth.users table (user was created during OTP send)\n    SELECT id INTO user_id\n    FROM auth.users\n    WHERE email = p_email\n    ORDER BY created_at DESC\n    LIMIT 1;\n    \n    IF NOT FOUND THEN\n        result := json_build_object(\n            'success', false,\n            'message', 'User not found in authentication system'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Check if user profile already exists\n    IF EXISTS (SELECT 1 FROM public.user_profiles WHERE id = user_id) THEN\n        -- Update existing profile\n        UPDATE public.user_profiles\n        SET \n            phone = COALESCE(p_phone, phone),\n            name = COALESCE(p_name, name),\n            phone_verified = CASE WHEN p_phone IS NOT NULL THEN TRUE ELSE phone_verified END,\n            updated_at = NOW()\n        WHERE id = user_id;\n        \n        result := json_build_object(\n            'success', true,\n            'message', 'User profile updated successfully',\n            'user_id', user_id\n        );\n    ELSE\n        -- Create new user profile\n        INSERT INTO public.user_profiles (\n            id, email, phone, name, phone_verified, created_at, updated_at\n        ) VALUES (\n            user_id, p_email, p_phone, p_name, \n            CASE WHEN p_phone IS NOT NULL THEN TRUE ELSE FALSE END,\n            NOW(), NOW()\n        );\n        \n        result := json_build_object(\n            'success', true,\n            'message', 'User profile created successfully',\n            'user_id', user_id\n        );\n    END IF;\n    \n    -- Clean up used OTP\n    DELETE FROM public.otp_verifications WHERE id = p_verification_id;\n    \n    RETURN result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "create_user_referral_code",
      "definition": "CREATE OR REPLACE FUNCTION public.create_user_referral_code(user_uuid uuid)\n RETURNS character varying\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    new_code VARCHAR(20);\n    existing_code VARCHAR(20);\nBEGIN\n    -- Check if user already has an active referral code\n    SELECT code INTO existing_code\n    FROM referral_codes\n    WHERE user_id = user_uuid AND is_active = true\n    LIMIT 1;\n    \n    -- If user already has a code, return it\n    IF existing_code IS NOT NULL THEN\n        RETURN existing_code;\n    END IF;\n    \n    -- Generate new code\n    new_code := generate_referral_code();\n    \n    -- Insert new referral code\n    INSERT INTO referral_codes (user_id, code, is_active)\n    VALUES (user_uuid, new_code, true);\n    \n    RETURN new_code;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "ensure_exam_stats_exist",
      "definition": "CREATE OR REPLACE FUNCTION public.ensure_exam_stats_exist()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- This function will be called before any query on exam_stats\n    -- It ensures that if a user tries to query exam_stats and no row exists,\n    -- we create a default row\n    RETURN NULL;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "expire_old_memberships",
      "definition": "CREATE OR REPLACE FUNCTION public.expire_old_memberships()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    expired_count INTEGER;\nBEGIN\n    UPDATE user_memberships \n    SET status = 'expired', updated_at = NOW()\n    WHERE status = 'active' \n    AND end_date <= NOW();\n    \n    GET DIAGNOSTICS expired_count = ROW_COUNT;\n    \n    -- Update user profiles for expired memberships\n    UPDATE user_profiles \n    SET membership_status = 'expired', updated_at = NOW()\n    WHERE id IN (\n        SELECT user_id FROM user_memberships \n        WHERE status = 'expired' \n        AND updated_at > NOW() - INTERVAL '1 minute'\n    );\n    \n    RETURN expired_count;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "force_upsert_user_profile",
      "definition": "CREATE OR REPLACE FUNCTION public.force_upsert_user_profile(p_user_id uuid, p_email text, p_pin text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    existing_user_id UUID;\n    result JSONB;\nBEGIN\n    -- First, delete any existing records with this email (except the current user)\n    DELETE FROM user_profiles \n    WHERE email = p_email AND id != p_user_id;\n    \n    -- Now try to insert or update\n    BEGIN\n        -- Try insert first\n        INSERT INTO user_profiles (id, email, pin, created_at, updated_at)\n        VALUES (p_user_id, p_email, p_pin, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created',\n            'user_id', p_user_id,\n            'email', p_email\n        );\n    EXCEPTION\n        WHEN unique_violation THEN\n            -- If insert fails, try update\n            UPDATE user_profiles\n            SET \n                email = p_email,\n                pin = COALESCE(p_pin, pin),\n                updated_at = NOW()\n            WHERE id = p_user_id;\n            \n            IF FOUND THEN\n                RETURN jsonb_build_object(\n                    'success', true,\n                    'is_new_user', false,\n                    'message', 'User profile updated',\n                    'user_id', p_user_id,\n                    'email', p_email\n                );\n            ELSE\n                RETURN jsonb_build_object(\n                    'success', false,\n                    'error', 'Failed to create or update profile'\n                );\n            END IF;\n        WHEN OTHERS THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'Database error: ' || SQLERRM\n            );\n    END;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "generate_otp",
      "definition": "CREATE OR REPLACE FUNCTION public.generate_otp(p_email text, p_phone text DEFAULT NULL::text, p_verification_type text DEFAULT 'email'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    otp_code TEXT;\n    expires_at TIMESTAMP WITH TIME ZONE;\n    result JSON;\nBEGIN\n    -- Generate 6-digit OTP\n    otp_code := LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');\n    \n    -- Set expiration time (10 minutes from now)\n    expires_at := NOW() + INTERVAL '10 minutes';\n    \n    -- Delete any existing OTP for this email/phone\n    DELETE FROM public.otp_verifications \n    WHERE email = p_email \n    AND (p_phone IS NULL OR phone = p_phone);\n    \n    -- Insert new OTP\n    INSERT INTO public.otp_verifications (\n        email, phone, otp_code, verification_type, expires_at\n    ) VALUES (\n        p_email, p_phone, otp_code, p_verification_type, expires_at\n    );\n    \n    -- Return OTP info (in production, don't return the actual OTP)\n    result := json_build_object(\n        'success', true,\n        'message', 'OTP generated successfully',\n        'expires_at', expires_at,\n        'otp_code', otp_code -- Remove this in production\n    );\n    \n    RETURN result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "generate_otp",
      "definition": "CREATE OR REPLACE FUNCTION public.generate_otp()\n RETURNS character varying\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "generate_referral_code",
      "definition": "CREATE OR REPLACE FUNCTION public.generate_referral_code(user_id uuid)\n RETURNS character varying\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    code VARCHAR(20);\n    counter INTEGER := 0;\nBEGIN\n    LOOP\n        -- Generate code: first 3 chars of user_id + random 4 digits\n        code := UPPER(SUBSTRING(user_id::text, 1, 3)) || LPAD(FLOOR(RANDOM() * 10000)::text, 4, '0');\n        \n        -- Check if code already exists\n        IF NOT EXISTS (SELECT 1 FROM user_profiles WHERE referral_code = code) THEN\n            RETURN code;\n        END IF;\n        \n        counter := counter + 1;\n        IF counter > 100 THEN\n            RAISE EXCEPTION 'Unable to generate unique referral code after 100 attempts';\n        END IF;\n    END LOOP;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "generate_referral_code",
      "definition": "CREATE OR REPLACE FUNCTION public.generate_referral_code()\n RETURNS character varying\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    new_code VARCHAR(20);\n    code_exists BOOLEAN;\nBEGIN\n    LOOP\n        -- Generate code: EXAM + 6 random characters\n        new_code := 'EXAM' || upper(substring(md5(random()::text) from 1 for 6));\n        \n        -- Check if code exists\n        SELECT EXISTS(SELECT 1 FROM referral_codes WHERE code = new_code) INTO code_exists;\n        \n        -- If code doesn't exist, return it\n        IF NOT code_exists THEN\n            RETURN new_code;\n        END IF;\n    END LOOP;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_admin_question_reports",
      "definition": "CREATE OR REPLACE FUNCTION public.get_admin_question_reports(p_status text DEFAULT NULL::text, p_exam_id text DEFAULT NULL::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id uuid, user_id uuid, exam_id text, exam_type text, test_id text, question_id text, question_number integer, issue_type text, issue_description text, status text, admin_notes text, resolved_at timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, user_email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        qr.id,\n        qr.user_id,\n        qr.exam_id,\n        qr.exam_type,\n        qr.test_id,\n        qr.question_id,\n        qr.question_number,\n        qr.issue_type,\n        qr.issue_description,\n        qr.status,\n        qr.admin_notes,\n        qr.resolved_at,\n        qr.created_at,\n        qr.updated_at,\n        up.email as user_email\n    FROM question_reports qr\n    LEFT JOIN user_profiles up ON qr.user_id = up.id\n    WHERE \n        (p_status IS NULL OR qr.status = p_status)\n        AND (p_exam_id IS NULL OR qr.exam_id = p_exam_id)\n    ORDER BY qr.created_at DESC\n    LIMIT p_limit\n    OFFSET p_offset;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_all_payments",
      "definition": "CREATE OR REPLACE FUNCTION public.get_all_payments(p_status text DEFAULT NULL::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id uuid, payment_id text, user_id uuid, plan_name text, amount numeric, status text, verification_status text, payment_reference text, created_at timestamp with time zone, paid_at timestamp with time zone, verified_at timestamp with time zone, expires_at timestamp with time zone, failed_reason text, dispute_reason text, admin_notes text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.id,\n        p.payment_id,\n        p.user_id,\n        p.plan_name,\n        p.amount,\n        p.status,\n        p.verification_status,\n        p.payment_reference,\n        p.created_at,\n        p.paid_at,\n        p.verified_at,\n        p.expires_at,\n        p.failed_reason,\n        p.dispute_reason,\n        p.admin_notes\n    FROM public.payments p\n    WHERE (p_status IS NULL OR p.status = p_status)\n    ORDER BY p.created_at DESC\n    LIMIT p_limit\n    OFFSET p_offset;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_last_10_test_scores",
      "definition": "CREATE OR REPLACE FUNCTION public.get_last_10_test_scores(user_uuid uuid, exam_name text)\n RETURNS TABLE(score integer, completed_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT tc.score, tc.completed_at\n    FROM test_completions tc\n    WHERE tc.user_id = user_uuid \n        AND tc.exam_id = exam_name \n        AND tc.test_type IN ('mock', 'pyq')\n    ORDER BY tc.completed_at DESC\n    LIMIT 10;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_membership_plan",
      "definition": "CREATE OR REPLACE FUNCTION public.get_membership_plan(plan_id text)\n RETURNS TABLE(id text, name text, description text, price numeric, currency text, duration_months integer, features jsonb, display_order integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        mp.id,\n        mp.name,\n        mp.description,\n        mp.price,\n        mp.currency,\n        mp.duration_months,\n        mp.features,\n        mp.display_order\n    FROM public.membership_plans mp\n    WHERE mp.id = plan_id AND mp.is_active = true;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_membership_plans",
      "definition": "CREATE OR REPLACE FUNCTION public.get_membership_plans()\n RETURNS TABLE(id text, name text, description text, price numeric, currency text, duration_months integer, features jsonb, display_order integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        mp.id,\n        mp.name,\n        mp.description,\n        mp.price,\n        mp.currency,\n        mp.duration_months,\n        mp.features,\n        mp.display_order\n    FROM public.membership_plans mp\n    WHERE mp.is_active = true\n    ORDER BY mp.display_order ASC;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_or_create_exam_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_or_create_exam_stats(user_uuid uuid, exam_name text)\n RETURNS TABLE(id uuid, user_id uuid, exam_id character varying, total_tests integer, best_score integer, average_score integer, rank integer, last_test_date timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Try to get existing stats\n    RETURN QUERY\n    SELECT \n        es.id,\n        es.user_id,\n        es.exam_id,\n        es.total_tests,\n        es.best_score,\n        es.average_score,\n        es.rank,\n        es.last_test_date\n    FROM public.exam_stats es\n    WHERE es.user_id = user_uuid\n        AND es.exam_id = exam_name;\n    \n    -- If no stats found, create default ones\n    IF NOT FOUND THEN\n        INSERT INTO public.exam_stats (user_id, exam_id, total_tests, best_score, average_score, rank, last_test_date)\n        VALUES (user_uuid, exam_name, 0, 0, 0, NULL, NULL);\n        \n        -- Return the newly created stats\n        RETURN QUERY\n        SELECT \n            es.id,\n            es.user_id,\n            es.exam_id,\n            es.total_tests,\n            es.best_score,\n            es.average_score,\n            es.rank,\n            es.last_test_date\n        FROM public.exam_stats es\n        WHERE es.user_id = user_uuid\n            AND es.exam_id = exam_name;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_or_create_user_streak",
      "definition": "CREATE OR REPLACE FUNCTION public.get_or_create_user_streak(user_uuid uuid)\n RETURNS TABLE(id uuid, user_id uuid, current_streak integer, longest_streak integer, total_tests_taken integer, last_activity_date date, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- First, update streak based on daily visits\n    PERFORM public.update_user_streak_from_visit(user_uuid);\n    \n    -- Then return the streak data\n    RETURN QUERY\n    SELECT \n        us.id,\n        us.user_id,\n        us.current_streak,\n        us.longest_streak,\n        us.total_tests_taken,\n        us.last_activity_date,\n        us.created_at,\n        us.updated_at\n    FROM public.user_streaks us\n    WHERE us.user_id = user_uuid;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_payment_audit_trail",
      "definition": "CREATE OR REPLACE FUNCTION public.get_payment_audit_trail(p_payment_id text)\n RETURNS TABLE(action text, performed_by uuid, old_status text, new_status text, reason text, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        pal.action,\n        pal.performed_by,\n        pal.old_status,\n        pal.new_status,\n        pal.reason,\n        pal.created_at\n    FROM public.payment_audit_log pal\n    JOIN public.payments p ON pal.payment_id = p.id\n    WHERE p.payment_id = p_payment_id\n    ORDER BY pal.created_at ASC;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_payment_status",
      "definition": "CREATE OR REPLACE FUNCTION public.get_payment_status(p_payment_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    payment_record RECORD;\nBEGIN\n    SELECT \n        id,\n        user_id,\n        razorpay_order_id,\n        razorpay_payment_id,\n        plan_id,\n        plan_name,\n        amount,\n        currency,\n        status,\n        payment_method,\n        created_at,\n        updated_at,\n        paid_at,\n        failed_at,\n        failed_reason\n    INTO payment_record\n    FROM public.payments \n    WHERE id = p_payment_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Payment not found'\n        );\n    END IF;\n    \n    RETURN json_build_object(\n        'success', true,\n        'payment', json_build_object(\n            'id', payment_record.id,\n            'user_id', payment_record.user_id,\n            'razorpay_order_id', payment_record.razorpay_order_id,\n            'razorpay_payment_id', payment_record.razorpay_payment_id,\n            'plan_id', payment_record.plan_id,\n            'plan_name', payment_record.plan_name,\n            'amount', payment_record.amount,\n            'currency', payment_record.currency,\n            'status', payment_record.status,\n            'payment_method', payment_record.payment_method,\n            'created_at', payment_record.created_at,\n            'updated_at', payment_record.updated_at,\n            'paid_at', payment_record.paid_at,\n            'failed_at', payment_record.failed_at,\n            'failed_reason', payment_record.failed_reason\n        )\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_payment_status",
      "definition": "CREATE OR REPLACE FUNCTION public.get_payment_status(p_payment_id text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    payment_record RECORD;\nBEGIN\n    SELECT * INTO payment_record\n    FROM public.payments\n    WHERE payment_id = p_payment_id;\n    \n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment not found'\n        );\n    END IF;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'payment_id', payment_record.payment_id,\n        'status', payment_record.status,\n        'verification_status', payment_record.verification_status,\n        'amount', payment_record.amount,\n        'plan_name', payment_record.plan_name,\n        'created_at', payment_record.created_at,\n        'expires_at', payment_record.expires_at\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_plan_features",
      "definition": "CREATE OR REPLACE FUNCTION public.get_plan_features(plan_id text)\n RETURNS TABLE(feature_name text, feature_description text, is_included boolean, display_order integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        mf.feature_name,\n        mf.feature_description,\n        mf.is_included,\n        mf.display_order\n    FROM public.membership_features mf\n    WHERE mf.plan_id = plan_id\n    ORDER BY mf.display_order ASC;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_question_report_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_question_report_stats()\n RETURNS TABLE(total_reports bigint, pending_reports bigint, resolved_reports bigint, rejected_reports bigint, reports_by_issue_type jsonb, reports_by_exam jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        COUNT(*) as total_reports,\n        COUNT(*) FILTER (WHERE status = 'pending') as pending_reports,\n        COUNT(*) FILTER (WHERE status = 'resolved') as resolved_reports,\n        COUNT(*) FILTER (WHERE status = 'rejected') as rejected_reports,\n        (\n            SELECT jsonb_object_agg(issue_type, count)\n            FROM (\n                SELECT issue_type, COUNT(*) as count\n                FROM question_reports\n                GROUP BY issue_type\n            ) issue_stats\n        ) as reports_by_issue_type,\n        (\n            SELECT jsonb_object_agg(exam_id, count)\n            FROM (\n                SELECT exam_id, COUNT(*) as count\n                FROM question_reports\n                GROUP BY exam_id\n            ) exam_stats\n        ) as reports_by_exam;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_referral_dashboard",
      "definition": "CREATE OR REPLACE FUNCTION public.get_referral_dashboard(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_result JSONB;\nBEGIN\n    SELECT json_build_object(\n        'referral_code', COALESCE(rc.code, ''),\n        'total_referrals', COALESCE(rc.total_referrals, 0),\n        'total_earnings', COALESCE(rc.total_earnings, 0),\n        'pending_earnings', COALESCE((\n            SELECT SUM(amount) FROM referral_transactions \n            WHERE referrer_id = user_uuid AND status = 'pending'\n        ), 0),\n        'paid_earnings', COALESCE((\n            SELECT SUM(amount) FROM referral_transactions \n            WHERE referrer_id = user_uuid AND status = 'processed'\n        ), 0),\n        'recent_referrals', COALESCE((\n            SELECT json_agg(json_build_object(\n                'referee_email', up.email,\n                'amount', rt.amount,\n                'created_at', rt.created_at,\n                'status', rt.status\n            )) FROM referral_transactions rt\n            JOIN user_profiles up ON rt.referee_id = up.id\n            WHERE rt.referrer_id = user_uuid\n            ORDER BY rt.created_at DESC\n            LIMIT 10\n        ), '[]'::json)\n    ) INTO v_result\n    FROM referral_codes rc\n    WHERE rc.user_id = user_uuid AND rc.is_active = true;\n\n    -- If no referral code exists, create one\n    IF v_result IS NULL THEN\n        INSERT INTO referral_codes (user_id, code) \n        VALUES (user_uuid, generate_referral_code())\n        RETURNING json_build_object(\n            'referral_code', code,\n            'total_referrals', 0,\n            'total_earnings', 0,\n            'pending_earnings', 0,\n            'paid_earnings', 0,\n            'recent_referrals', '[]'::json\n        ) INTO v_result;\n    END IF;\n\n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_referral_leaderboard",
      "definition": "CREATE OR REPLACE FUNCTION public.get_referral_leaderboard(limit_count integer DEFAULT 10)\n RETURNS TABLE(user_id uuid, phone text, rank_position bigint, total_referrals bigint, total_earnings numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        up.id,\n        up.phone,\n        ROW_NUMBER() OVER (ORDER BY COALESCE(rc.total_earnings, 0) DESC) as rank_position,\n        COALESCE(rc.total_referrals, 0) as total_referrals,\n        COALESCE(rc.total_earnings, 0) as total_earnings\n    FROM user_profiles up\n    LEFT JOIN referral_codes rc ON up.id = rc.user_id\n    WHERE rc.total_referrals > 0\n    ORDER BY COALESCE(rc.total_earnings, 0) DESC\n    LIMIT limit_count;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_referral_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_referral_stats(user_id_input uuid)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    stats JSON;\nBEGIN\n    SELECT json_build_object(\n        'total_referrals', COALESCE(up.total_referrals, 0),\n        'total_earnings', COALESCE(up.referral_earnings, 0),\n        'referral_code', COALESCE(up.referral_code, ''),\n        'max_referrals', COALESCE(up.max_referrals, 20),\n        'commission_rate', COALESCE(up.referral_commission_rate, 50.00),\n        'pending_rewards', COALESCE((\n            SELECT COUNT(*) FROM referral_tracking \n            WHERE referrer_id = user_id_input AND status = 'pending'\n        ), 0),\n        'verified_referrals', COALESCE((\n            SELECT COUNT(*) FROM referral_tracking \n            WHERE referrer_id = user_id_input AND verification_completed = TRUE\n        ), 0),\n        'rewarded_referrals', COALESCE((\n            SELECT COUNT(*) FROM referral_tracking \n            WHERE referrer_id = user_id_input AND reward_credited = TRUE\n        ), 0)\n    ) INTO stats\n    FROM user_profiles up\n    WHERE up.id = user_id_input;\n    \n    RETURN COALESCE(stats, '{}'::json);\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_membership",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_membership(user_uuid uuid)\n RETURNS TABLE(membership_id uuid, plan_id character varying, status character varying, start_date timestamp with time zone, end_date timestamp with time zone, days_remaining integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        um.id,\n        um.plan_id,\n        um.status,\n        um.start_date,\n        um.end_date,\n        GREATEST(0, EXTRACT(DAY FROM (um.end_date - NOW()))::INTEGER) as days_remaining\n    FROM user_memberships um\n    WHERE um.user_id = user_uuid \n    AND um.status = 'active'\n    AND um.end_date > NOW()\n    ORDER BY um.created_at DESC\n    LIMIT 1;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_membership_status",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_membership_status(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_result JSONB;\nBEGIN\n    SELECT json_build_object(\n        'has_active_membership', CASE \n            WHEN um.status = 'active' AND um.end_date > NOW() THEN true \n            ELSE false \n        END,\n        'current_plan', COALESCE(um.plan_id, 'free'),\n        'expires_at', um.end_date,\n        'days_remaining', CASE \n            WHEN um.status = 'active' AND um.end_date > NOW() \n            THEN EXTRACT(DAY FROM (um.end_date - NOW()))::INTEGER\n            ELSE 0 \n        END,\n        'tests_available', COALESCE(mp.mock_tests, 0),\n        'plan_name', COALESCE(mp.name, 'Free Plan')\n    ) INTO v_result\n    FROM user_profiles up\n    LEFT JOIN user_memberships um ON up.id = um.user_id AND um.status = 'active'\n    LEFT JOIN membership_plans mp ON um.plan_id = mp.id\n    WHERE up.id = user_uuid;\n\n    RETURN COALESCE(v_result, json_build_object(\n        'has_active_membership', false,\n        'current_plan', 'free',\n        'expires_at', null,\n        'days_remaining', 0,\n        'tests_available', 0,\n        'plan_name', 'Free Plan'\n    ));\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_payments",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_payments(p_user_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    payments JSON;\nBEGIN\n    SELECT json_agg(\n        json_build_object(\n            'id', id,\n            'razorpay_order_id', razorpay_order_id,\n            'razorpay_payment_id', razorpay_payment_id,\n            'plan_id', plan_id,\n            'plan_name', plan_name,\n            'amount', amount,\n            'currency', currency,\n            'status', status,\n            'payment_method', payment_method,\n            'created_at', created_at,\n            'updated_at', updated_at,\n            'paid_at', paid_at,\n            'failed_at', failed_at,\n            'failed_reason', failed_reason\n        )\n    ) INTO payments\n    FROM public.payments \n    WHERE user_id = p_user_id\n    ORDER BY created_at DESC;\n    \n    RETURN json_build_object(\n        'success', true,\n        'payments', COALESCE(payments, '[]'::json)\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_performance_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_performance_stats(user_uuid uuid, exam_name text)\n RETURNS TABLE(best_score integer, average_score_last_10 numeric, total_tests integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    best_score_val INTEGER;\n    avg_score_val NUMERIC;\n    total_tests_val INTEGER;\n    total_marks INTEGER;\n    obtained_marks INTEGER;\nBEGIN\n    -- Calculate best score based on actual marks obtained\n    -- Assuming each test has 100 questions with 2 marks each = 200 total marks\n    SELECT COALESCE(MAX(\n        CASE \n            WHEN total_questions > 0 THEN \n                ROUND((score::NUMERIC / 100) * (total_questions * 2))\n            ELSE 0 \n        END\n    ), 0) INTO best_score_val\n    FROM test_completions\n    WHERE user_id = user_uuid \n        AND exam_id = exam_name \n        AND test_type IN ('mock', 'pyq');\n    \n    -- Get average of last 10 tests (actual marks)\n    SELECT COALESCE(AVG(\n        CASE \n            WHEN total_questions > 0 THEN \n                ROUND((score::NUMERIC / 100) * (total_questions * 2))\n            ELSE 0 \n        END\n    ), 0) INTO avg_score_val\n    FROM (\n        SELECT score, total_questions\n        FROM test_completions\n        WHERE user_id = user_uuid \n            AND exam_id = exam_name \n            AND test_type IN ('mock', 'pyq')\n        ORDER BY completed_at DESC\n        LIMIT 10\n    ) last_10_tests;\n    \n    -- Get total unique test count\n    SELECT COUNT(DISTINCT CONCAT(test_type, '-', test_id)) INTO total_tests_val\n    FROM test_completions\n    WHERE user_id = user_uuid \n        AND exam_id = exam_name \n        AND test_type IN ('mock', 'pyq');\n    \n    RETURN QUERY SELECT best_score_val, ROUND(avg_score_val, 2), total_tests_val;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_profile_with_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_profile_with_stats(p_user_id uuid)\n RETURNS TABLE(id uuid, name character varying, phone character varying, phone_verified boolean, upi_id character varying, referral_earnings numeric, total_referrals integer, total_earnings numeric, pending_earnings numeric, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        up.id,\n        up.name,\n        up.phone,\n        up.phone_verified,\n        up.upi_id,\n        up.referral_earnings,\n        up.total_referrals,\n        COALESCE(SUM(rt.amount) FILTER (WHERE rt.transaction_type = 'earning' AND rt.status = 'completed'), 0) as total_earnings,\n        COALESCE(SUM(rt.amount) FILTER (WHERE rt.transaction_type = 'withdrawal' AND rt.status = 'pending'), 0) as pending_earnings,\n        up.created_at,\n        up.updated_at\n    FROM public.user_profiles up\n    LEFT JOIN public.referral_transactions rt ON up.id = rt.referrer_id\n    WHERE up.id = p_user_id\n    GROUP BY up.id, up.name, up.phone, up.phone_verified, up.upi_id, \n             up.referral_earnings, up.total_referrals, up.created_at, up.updated_at;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_question_reports",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_question_reports(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(id uuid, exam_id text, exam_type text, test_id text, question_id text, question_number integer, issue_type text, issue_description text, status text, admin_notes text, resolved_at timestamp with time zone, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        qr.id,\n        qr.exam_id,\n        qr.exam_type,\n        qr.test_id,\n        qr.question_id,\n        qr.question_number,\n        qr.issue_type,\n        qr.issue_description,\n        qr.status,\n        qr.admin_notes,\n        qr.resolved_at,\n        qr.created_at\n    FROM question_reports qr\n    WHERE qr.user_id = p_user_id\n    ORDER BY qr.created_at DESC;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_referral_code",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_referral_code(user_id uuid)\n RETURNS character varying\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_referral_code VARCHAR(20);\nBEGIN\n    SELECT referral_code INTO v_referral_code\n    FROM public.user_profiles\n    WHERE id = user_id;\n    \n    RETURN v_referral_code;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_referral_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_referral_stats(user_uuid uuid)\n RETURNS TABLE(total_referrals integer, total_earnings numeric, pending_earnings numeric, paid_earnings numeric, referral_code character varying)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        COALESCE(rc.total_referrals, 0)::INTEGER,\n        COALESCE(rc.total_earnings, 0),\n        COALESCE(SUM(CASE WHEN r.status = 'pending' THEN r.commission_amount ELSE 0 END), 0),\n        COALESCE(SUM(CASE WHEN r.status = 'paid' THEN r.commission_amount ELSE 0 END), 0),\n        COALESCE(rc.code, '')\n    FROM referral_codes rc\n    LEFT JOIN referrals r ON rc.user_id = r.referrer_id\n    WHERE rc.user_id = user_uuid AND rc.is_active = true\n    GROUP BY rc.id, rc.total_referrals, rc.total_earnings, rc.code;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "get_user_test_score",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_test_score(user_uuid uuid, exam_name text, test_type_name text, test_name text)\n RETURNS TABLE(score integer, rank integer, total_participants integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    its.score,\n    its.rank,\n    its.total_participants\n  FROM individual_test_scores its\n  WHERE its.user_id = user_uuid \n    AND its.exam_id = exam_name \n    AND its.test_type = test_type_name \n    AND its.test_id = test_name;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "grant_admin_access",
      "definition": "CREATE OR REPLACE FUNCTION public.grant_admin_access(user_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Update user_profiles to set is_admin = true\n    UPDATE public.user_profiles\n    SET is_admin = TRUE, updated_at = NOW()\n    WHERE id = user_uuid;\n    \n    -- Check if update was successful\n    IF FOUND THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "handle_new_user",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.user_profiles (id, phone, created_at, updated_at)\n  VALUES (new.id, new.phone, now(), now());\n  RETURN new;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "has_active_membership",
      "definition": "CREATE OR REPLACE FUNCTION public.has_active_membership(user_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN EXISTS (\n        SELECT 1 FROM user_memberships \n        WHERE user_id = user_uuid \n        AND status = 'active' \n        AND end_date > NOW()\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "has_mock_test_access",
      "definition": "CREATE OR REPLACE FUNCTION public.has_mock_test_access(user_uuid uuid, required_tests integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_plan_id VARCHAR(20);\n    plan_mock_tests INTEGER;\nBEGIN\n    -- Get user's current plan\n    SELECT um.plan_id INTO user_plan_id\n    FROM user_memberships um\n    WHERE um.user_id = user_uuid \n    AND um.status = 'active'\n    AND um.end_date > NOW()\n    ORDER BY um.created_at DESC\n    LIMIT 1;\n    \n    -- If no active membership, return false\n    IF user_plan_id IS NULL THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Get plan details\n    SELECT mp.mock_tests INTO plan_mock_tests\n    FROM membership_plans mp\n    WHERE mp.id = user_plan_id;\n    \n    -- Check if user has access to required tests\n    RETURN plan_mock_tests >= required_tests;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "initialize_user_exam_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.initialize_user_exam_stats(p_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Initialize stats for all exam types\n    PERFORM public.upsert_exam_stats(p_user_id, 'ssc-cgl', 0, 0, 0, NULL, NULL);\n    PERFORM public.upsert_exam_stats(p_user_id, 'ssc-mts', 0, 0, 0, NULL, NULL);\n    PERFORM public.upsert_exam_stats(p_user_id, 'railway', 0, 0, 0, NULL, NULL);\n    PERFORM public.upsert_exam_stats(p_user_id, 'bank-po', 0, 0, 0, NULL, NULL);\n    PERFORM public.upsert_exam_stats(p_user_id, 'airforce', 0, 0, 0, NULL, NULL);\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "is_test_completed",
      "definition": "CREATE OR REPLACE FUNCTION public.is_test_completed(user_uuid uuid, exam_name text, test_type_name text, test_name text, topic_name text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Handle NULL topic_name properly\n  IF topic_name IS NULL THEN\n    RETURN EXISTS (\n      SELECT 1 \n      FROM test_completions tc\n      WHERE tc.user_id = user_uuid \n        AND tc.exam_id = exam_name \n        AND tc.test_type = test_type_name \n        AND tc.test_id = test_name \n        AND tc.topic_id IS NULL\n    );\n  ELSE\n    RETURN EXISTS (\n      SELECT 1 \n      FROM test_completions tc\n      WHERE tc.user_id = user_uuid \n        AND tc.exam_id = exam_name \n        AND tc.test_type = test_type_name \n        AND tc.test_id = test_name \n        AND tc.topic_id = topic_name\n    );\n  END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "is_test_completed_simple",
      "definition": "CREATE OR REPLACE FUNCTION public.is_test_completed_simple(user_uuid uuid, exam_name character varying, test_type_name character varying, test_name character varying)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN EXISTS(\n    SELECT 1 FROM test_completions \n    WHERE user_id = user_uuid \n      AND exam_id = exam_name \n      AND test_type = test_type_name \n      AND test_id = test_name\n      -- Ignore topic_id completely for now\n  );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "is_user_admin",
      "definition": "CREATE OR REPLACE FUNCTION public.is_user_admin(user_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    admin_status BOOLEAN;\nBEGIN\n    -- Check if user is admin in user_profiles\n    SELECT is_admin INTO admin_status\n    FROM public.user_profiles\n    WHERE id = user_uuid;\n    \n    -- Return admin status (default to false if user not found)\n    RETURN COALESCE(admin_status, FALSE);\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "log_webhook_event",
      "definition": "CREATE OR REPLACE FUNCTION public.log_webhook_event(p_event_id text, p_event_type text, p_payment_id text DEFAULT NULL::text, p_order_id text DEFAULT NULL::text, p_raw_data jsonb DEFAULT NULL::jsonb)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    event_id TEXT;\nBEGIN\n    INSERT INTO public.webhook_events (\n        event_id,\n        event_type,\n        payment_id,\n        order_id,\n        raw_data\n    ) VALUES (\n        p_event_id,\n        p_event_type,\n        p_payment_id,\n        p_order_id,\n        p_raw_data\n    ) RETURNING id INTO event_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'event_id', event_id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "mark_payment_paid",
      "definition": "CREATE OR REPLACE FUNCTION public.mark_payment_paid(p_payment_id text, p_reference_id text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    payment_record RECORD;\nBEGIN\n    -- Check if payment exists and is pending\n    SELECT * INTO payment_record\n    FROM public.payments\n    WHERE payment_id = p_payment_id \n        AND status = 'pending'\n        AND expires_at > NOW();\n    \n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment not found or expired'\n        );\n    END IF;\n    \n    -- Update payment status to paid\n    UPDATE public.payments\n    SET status = 'paid',\n        payment_reference = p_reference_id,\n        paid_at = NOW(),\n        verification_status = 'pending'\n    WHERE id = payment_record.id;\n    \n    -- Log the action\n    INSERT INTO public.payment_audit_log (\n        payment_id, action, old_status, new_status, reason\n    ) VALUES (\n        payment_record.id, 'paid', 'pending', 'paid', 'User claimed payment made'\n    );\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Payment marked as paid, awaiting verification',\n        'payment_id', payment_record.payment_id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "mark_webhook_processed",
      "definition": "CREATE OR REPLACE FUNCTION public.mark_webhook_processed(p_event_id text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    UPDATE public.webhook_events \n    SET processed = true\n    WHERE event_id = p_event_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Webhook event not found'\n        );\n    END IF;\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Webhook marked as processed'\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "perform_payment_verification",
      "definition": "CREATE OR REPLACE FUNCTION public.perform_payment_verification(payment_record record, reference_id text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- This is a simulation function\n    -- In production, you would:\n    -- 1. Call your payment gateway API (Razorpay, PhonePe, etc.)\n    -- 2. Verify the transaction reference\n    -- 3. Check amount, timestamp, and other details\n    -- 4. Return true if verification successful\n    \n    -- For now, we'll simulate verification based on reference ID format\n    -- A real UPI reference typically starts with specific patterns\n    IF reference_id ~ '^[A-Z0-9]{8,12}$' THEN\n        RETURN true;\n    ELSE\n        RETURN false;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "process_membership_purchase",
      "definition": "CREATE OR REPLACE FUNCTION public.process_membership_purchase(user_uuid uuid, plan_id_param character varying, amount_param numeric, payment_id_param character varying, referral_code_used character varying DEFAULT NULL::character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_membership_id UUID;\n    v_referrer_id UUID;\n    v_commission_amount DECIMAL(10,2) := 0;\n    v_plan_details RECORD;\n    v_result JSONB;\nBEGIN\n    -- Get plan details\n    SELECT * INTO v_plan_details FROM membership_plans WHERE id = plan_id_param;\n    \n    IF v_plan_details IS NULL THEN\n        RETURN json_build_object('success', false, 'error', 'Invalid plan');\n    END IF;\n\n    -- Create membership\n    INSERT INTO user_memberships (\n        user_id, plan_id, status, start_date, end_date, payment_id\n    ) VALUES (\n        user_uuid, \n        plan_id_param, \n        'active', \n        NOW(), \n        NOW() + INTERVAL '1 day' * v_plan_details.duration_days,\n        payment_id_param\n    ) RETURNING id INTO v_membership_id;\n\n    -- Update user profile\n    UPDATE user_profiles \n    SET \n        membership_plan = plan_id_param,\n        membership_status = 'active',\n        membership_expiry = NOW() + INTERVAL '1 day' * v_plan_details.duration_days,\n        updated_at = NOW()\n    WHERE id = user_uuid;\n\n    -- Process referral if code provided\n    IF referral_code_used IS NOT NULL THEN\n        -- Find referrer\n        SELECT user_id INTO v_referrer_id \n        FROM referral_codes \n        WHERE code = referral_code_used AND is_active = true;\n\n        IF v_referrer_id IS NOT NULL AND v_referrer_id != user_uuid THEN\n            -- Calculate commission (10% of purchase)\n            v_commission_amount := amount_param * 0.10;\n            \n            -- Create referral transaction\n            INSERT INTO referral_transactions (\n                referrer_id, referee_id, transaction_type, amount, \n                description, payment_id\n            ) VALUES (\n                v_referrer_id, user_uuid, 'commission', v_commission_amount,\n                'Commission from ' || plan_id_param || ' plan purchase', payment_id_param\n            );\n\n            -- Update referral code stats\n            UPDATE referral_codes \n            SET \n                total_referrals = total_referrals + 1,\n                total_earnings = total_earnings + v_commission_amount,\n                updated_at = NOW()\n            WHERE user_id = v_referrer_id AND is_active = true;\n        END IF;\n    END IF;\n\n    -- Record membership transaction\n    INSERT INTO membership_transactions (\n        user_id, membership_id, amount, commission_paid, \n        referral_code_used, transaction_id\n    ) VALUES (\n        user_uuid, v_membership_id, amount_param, v_commission_amount,\n        referral_code_used, payment_id_param\n    );\n\n    -- Return success with details\n    SELECT json_build_object(\n        'success', true,\n        'membership_id', v_membership_id,\n        'plan_id', plan_id_param,\n        'commission_paid', v_commission_amount,\n        'expires_at', NOW() + INTERVAL '1 day' * v_plan_details.duration_days\n    ) INTO v_result;\n\n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "process_referral",
      "definition": "CREATE OR REPLACE FUNCTION public.process_referral(referee_uuid uuid, referral_code_param character varying, purchase_amount_param numeric, purchase_id_param character varying)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    referrer_uuid UUID;\n    commission_amount DECIMAL(10,2);\n    commission_percentage INTEGER := 50;\n    existing_referral UUID;\nBEGIN\n    -- Find referrer by code\n    SELECT user_id INTO referrer_uuid\n    FROM referral_codes\n    WHERE code = referral_code_param AND is_active = true;\n    \n    -- If referrer not found, return false\n    IF referrer_uuid IS NULL THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check if user is trying to refer themselves\n    IF referrer_uuid = referee_uuid THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check if this referee has already been referred by this referrer\n    SELECT id INTO existing_referral\n    FROM referrals\n    WHERE referrer_id = referrer_uuid AND referee_id = referee_uuid;\n    \n    -- If already referred, return false\n    IF existing_referral IS NOT NULL THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Calculate commission\n    commission_amount := (purchase_amount_param * commission_percentage) / 100;\n    \n    -- Create referral record\n    INSERT INTO referrals (\n        referrer_id,\n        referee_id,\n        referral_code,\n        purchase_amount,\n        commission_amount,\n        commission_percentage,\n        status,\n        purchase_id\n    ) VALUES (\n        referrer_uuid,\n        referee_uuid,\n        referral_code_param,\n        purchase_amount_param,\n        commission_amount,\n        commission_percentage,\n        'pending',\n        purchase_id_param\n    );\n    \n    -- Update referral code stats\n    UPDATE referral_codes\n    SET \n        total_referrals = total_referrals + 1,\n        total_earnings = total_earnings + commission_amount,\n        updated_at = NOW()\n    WHERE id = (\n        SELECT id FROM referral_codes \n        WHERE code = referral_code_param AND is_active = true\n    );\n    \n    RETURN TRUE;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "process_referral_earnings",
      "definition": "CREATE OR REPLACE FUNCTION public.process_referral_earnings(referred_user_id uuid, transaction_amount numeric, transaction_id uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_referrer_id UUID;\n    v_referral_code VARCHAR(20);\n    v_earnings_amount DECIMAL(10,2);\n    v_percentage DECIMAL(5,2) := 50.00; -- Configurable: 50% for first purchase\n    v_result JSONB;\nBEGIN\n    -- Get referrer information\n    SELECT rm.referrer_id, rm.referral_code\n    INTO v_referrer_id, v_referral_code\n    FROM public.referral_mappings rm\n    WHERE rm.referred_id = referred_user_id;\n    \n    IF v_referrer_id IS NULL THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'No referrer found for this user'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Check if earnings already processed for this transaction\n    IF transaction_id IS NOT NULL AND EXISTS (\n        SELECT 1 FROM public.referral_earnings \n        WHERE transaction_id = process_referral_earnings.transaction_id\n    ) THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'Earnings already processed for this transaction'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Calculate earnings (50% of transaction amount)\n    v_earnings_amount := (transaction_amount * v_percentage) / 100.00;\n    \n    -- Create referral earnings record\n    INSERT INTO public.referral_earnings (\n        referrer_id, \n        referred_id, \n        transaction_id, \n        amount, \n        percentage, \n        status\n    )\n    VALUES (\n        v_referrer_id, \n        referred_user_id, \n        transaction_id, \n        v_earnings_amount, \n        v_percentage, \n        'pending'\n    );\n    \n    -- Update referrer's total earnings in user_profiles\n    UPDATE public.user_profiles\n    SET \n        referral_earnings = COALESCE(referral_earnings, 0) + v_earnings_amount,\n        total_referrals = COALESCE(total_referrals, 0) + 1,\n        updated_at = NOW()\n    WHERE id = v_referrer_id;\n    \n    -- Log the transaction\n    INSERT INTO public.referral_transactions (\n        referrer_id, \n        referred_id, \n        transaction_type, \n        amount, \n        referral_code,\n        metadata\n    )\n    VALUES (\n        v_referrer_id, \n        referred_user_id, \n        'purchase', \n        v_earnings_amount, \n        v_referral_code,\n        jsonb_build_object(\n            'transaction_amount', transaction_amount,\n            'percentage', v_percentage,\n            'transaction_id', transaction_id\n        )\n    );\n    \n    v_result := jsonb_build_object(\n        'success', true,\n        'message', 'Referral earnings processed successfully',\n        'referrer_id', v_referrer_id,\n        'earnings_amount', v_earnings_amount\n    );\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "process_referral_reward",
      "definition": "CREATE OR REPLACE FUNCTION public.process_referral_reward(tracking_id_input uuid, reward_type_input character varying, base_amount_input numeric DEFAULT NULL::numeric)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    tracking_record RECORD;\n    reward_amount DECIMAL(10,2);\n    commission_rate DECIMAL(5,2);\n    reward_id UUID;\n    result JSON;\nBEGIN\n    -- Get tracking record\n    SELECT * INTO tracking_record \n    FROM referral_tracking \n    WHERE id = tracking_id_input;\n    \n    IF tracking_record IS NULL THEN\n        RETURN json_build_object('success', false, 'message', 'Tracking record not found');\n    END IF;\n    \n    -- Check if reward already processed\n    IF tracking_record.reward_credited THEN\n        RETURN json_build_object('success', false, 'message', 'Reward already credited');\n    END IF;\n    \n    -- Get commission rate\n    SELECT referral_commission_rate INTO commission_rate\n    FROM user_profiles \n    WHERE id = tracking_record.referrer_id;\n    \n    -- Calculate reward amount\n    IF reward_type_input = 'verification' THEN\n        reward_amount := 10.00; -- Fixed amount for verification\n    ELSIF reward_type_input = 'purchase' THEN\n        reward_amount := (base_amount_input * commission_rate / 100);\n    ELSIF reward_type_input = 'milestone' THEN\n        reward_amount := 25.00; -- Fixed amount for milestone\n    ELSE\n        RETURN json_build_object('success', false, 'message', 'Invalid reward type');\n    END IF;\n    \n    -- Create reward record\n    INSERT INTO referral_rewards (\n        referrer_id, referred_id, tracking_id, reward_type, \n        reward_amount, commission_rate, base_amount, status\n    ) VALUES (\n        tracking_record.referrer_id, tracking_record.referred_id, tracking_id_input,\n        reward_type_input, reward_amount, commission_rate, base_amount_input, 'pending'\n    ) RETURNING id INTO reward_id;\n    \n    -- Update referrer's earnings\n    UPDATE user_profiles \n    SET referral_earnings = referral_earnings + reward_amount,\n        updated_at = NOW()\n    WHERE id = tracking_record.referrer_id;\n    \n    -- Update tracking record\n    UPDATE referral_tracking \n    SET reward_credited = TRUE,\n        reward_amount = reward_amount,\n        reward_date = NOW(),\n        status = 'rewarded',\n        updated_at = NOW()\n    WHERE id = tracking_id_input;\n    \n    -- Update reward status\n    UPDATE referral_rewards \n    SET status = 'credited',\n        credited_at = NOW()\n    WHERE id = reward_id;\n    \n    -- Log event\n    INSERT INTO referral_events (event_type, referrer_id, referred_id, tracking_id, event_data)\n    VALUES ('reward_credited', tracking_record.referrer_id, tracking_record.referred_id, \n            tracking_id_input, json_build_object('reward_type', reward_type_input, 'amount', reward_amount));\n    \n    RETURN json_build_object(\n        'success', true, \n        'message', 'Reward processed successfully',\n        'reward_amount', reward_amount,\n        'reward_id', reward_id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "request_referral_payout",
      "definition": "CREATE OR REPLACE FUNCTION public.request_referral_payout(user_uuid uuid, amount_param numeric, payment_method_param character varying, payment_details_param jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    pending_earnings DECIMAL(10,2);\n    min_payout DECIMAL(10,2) := 100.00;\nBEGIN\n    -- Get user's pending earnings\n    SELECT COALESCE(SUM(commission_amount), 0) INTO pending_earnings\n    FROM referrals\n    WHERE referrer_id = user_uuid AND status = 'pending';\n    \n    -- Check if user has enough pending earnings\n    IF pending_earnings < amount_param THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Check minimum payout amount\n    IF amount_param < min_payout THEN\n        RETURN FALSE;\n    END IF;\n    \n    -- Create payout request\n    INSERT INTO referral_payouts (\n        user_id,\n        amount,\n        status,\n        payment_method,\n        payment_details\n    ) VALUES (\n        user_uuid,\n        amount_param,\n        'pending',\n        payment_method_param,\n        payment_details_param\n    );\n    \n    RETURN TRUE;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "revoke_admin_access",
      "definition": "CREATE OR REPLACE FUNCTION public.revoke_admin_access(user_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Update user_profiles to set is_admin = false\n    UPDATE public.user_profiles\n    SET is_admin = FALSE, updated_at = NOW()\n    WHERE id = user_uuid;\n    \n    -- Check if update was successful\n    IF FOUND THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "safe_create_user_profile",
      "definition": "CREATE OR REPLACE FUNCTION public.safe_create_user_profile(p_user_id uuid, p_email text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    existing_user_id UUID;\n    result JSONB;\nBEGIN\n    -- Check if email already exists\n    SELECT id INTO existing_user_id\n    FROM user_profiles\n    WHERE email = p_email;\n    \n    IF existing_user_id IS NOT NULL THEN\n        -- Email already exists, return error\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Email already exists',\n            'existing_user_id', existing_user_id\n        );\n    END IF;\n    \n    -- Check if user profile already exists\n    SELECT id INTO existing_user_id\n    FROM user_profiles\n    WHERE id = p_user_id;\n    \n    IF existing_user_id IS NOT NULL THEN\n        -- User profile already exists, update it\n        UPDATE user_profiles\n        SET \n            email = p_email,\n            updated_at = NOW()\n        WHERE id = p_user_id;\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', false,\n            'message', 'User profile updated'\n        );\n    ELSE\n        -- Create new user profile\n        INSERT INTO user_profiles (id, email, created_at, updated_at)\n        VALUES (p_user_id, p_email, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created'\n        );\n    END IF;\n    \nEXCEPTION\n    WHEN unique_violation THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Email already exists'\n        );\n    WHEN OTHERS THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', SQLERRM\n        );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "safe_get_user_profile",
      "definition": "CREATE OR REPLACE FUNCTION public.safe_get_user_profile(p_user_id uuid)\n RETURNS TABLE(id uuid, email text, name text, phone text, phone_verified boolean, upi_id text, referral_earnings numeric, total_referrals integer, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        up.id,\n        up.email,\n        COALESCE(up.name, '') as name,\n        COALESCE(up.phone, '') as phone,\n        COALESCE(up.phone_verified, false) as phone_verified,\n        COALESCE(up.upi_id, '') as upi_id,\n        COALESCE(up.referral_earnings, 0) as referral_earnings,\n        COALESCE(up.total_referrals, 0) as total_referrals,\n        up.created_at,\n        up.updated_at\n    FROM user_profiles up\n    WHERE up.id = p_user_id;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "safe_upsert_user_profile",
      "definition": "CREATE OR REPLACE FUNCTION public.safe_upsert_user_profile(p_user_id uuid, p_email text, p_pin text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    existing_user_id UUID;\n    result JSONB;\nBEGIN\n    -- Check if email already exists with a different user_id\n    SELECT id INTO existing_user_id\n    FROM user_profiles\n    WHERE email = p_email AND id != p_user_id;\n    \n    IF existing_user_id IS NOT NULL THEN\n        -- Email already exists with different user, return error\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Email already in use by another user',\n            'existing_user_id', existing_user_id\n        );\n    END IF;\n    \n    -- Check if user profile already exists\n    SELECT id INTO existing_user_id\n    FROM user_profiles\n    WHERE id = p_user_id;\n    \n    IF existing_user_id IS NOT NULL THEN\n        -- User profile already exists, update it\n        UPDATE user_profiles\n        SET \n            email = p_email,\n            pin = COALESCE(p_pin, pin),\n            updated_at = NOW()\n        WHERE id = p_user_id;\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', false,\n            'message', 'User profile updated'\n        );\n    ELSE\n        -- Create new user profile\n        INSERT INTO user_profiles (id, email, pin, created_at, updated_at)\n        VALUES (p_user_id, p_email, p_pin, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created'\n        );\n    END IF;\n    \nEXCEPTION\n    WHEN unique_violation THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Email already exists'\n        );\n    WHEN OTHERS THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', SQLERRM\n        );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "safe_upsert_user_profile_v2",
      "definition": "CREATE OR REPLACE FUNCTION public.safe_upsert_user_profile_v2(p_user_id uuid, p_email text, p_pin text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    existing_user_id UUID;\n    existing_email TEXT;\n    result JSONB;\nBEGIN\n    -- Check if email already exists with a different user_id\n    SELECT id, email INTO existing_user_id, existing_email\n    FROM user_profiles\n    WHERE email = p_email;\n    \n    IF existing_user_id IS NOT NULL AND existing_user_id != p_user_id THEN\n        -- Email already exists with different user, return error\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Email already in use by another user',\n            'existing_user_id', existing_user_id,\n            'existing_email', existing_email\n        );\n    END IF;\n    \n    -- Check if user profile already exists\n    SELECT id INTO existing_user_id\n    FROM user_profiles\n    WHERE id = p_user_id;\n    \n    IF existing_user_id IS NOT NULL THEN\n        -- User profile already exists, update it\n        UPDATE user_profiles\n        SET \n            email = p_email,\n            pin = COALESCE(p_pin, pin),\n            updated_at = NOW()\n        WHERE id = p_user_id;\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', false,\n            'message', 'User profile updated',\n            'user_id', p_user_id,\n            'email', p_email\n        );\n    ELSE\n        -- Create new user profile\n        INSERT INTO user_profiles (id, email, pin, created_at, updated_at)\n        VALUES (p_user_id, p_email, p_pin, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created',\n            'user_id', p_user_id,\n            'email', p_email\n        );\n    END IF;\n    \nEXCEPTION\n    WHEN unique_violation THEN\n        -- Handle unique constraint violations\n        IF SQLSTATE = '23505' THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'Email already exists',\n                'sqlstate', SQLSTATE\n            );\n        END IF;\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Unique constraint violation: ' || SQLERRM,\n            'sqlstate', SQLSTATE\n        );\n    WHEN OTHERS THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Database error: ' || SQLERRM,\n            'sqlstate', SQLSTATE\n        );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "send_otp_to_phone",
      "definition": "CREATE OR REPLACE FUNCTION public.send_otp_to_phone(user_uuid uuid, phone_number character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_otp VARCHAR(6);\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_result JSONB;\nBEGIN\n    -- Generate 6-digit OTP\n    v_otp := public.generate_otp();\n    \n    -- Set expiration time (5 minutes from now)\n    v_expires_at := NOW() + INTERVAL '5 minutes';\n    \n    -- Clean up old OTPs for this user\n    DELETE FROM public.phone_verifications \n    WHERE user_id = user_uuid \n    AND (expires_at < NOW() OR verified = TRUE);\n    \n    -- Insert new OTP\n    INSERT INTO public.phone_verifications (user_id, phone, otp_code, expires_at)\n    VALUES (user_uuid, phone_number, v_otp, v_expires_at);\n    \n    -- TODO: Integrate with SMS service here\n    -- For now, we'll log the OTP (remove this in production)\n    RAISE NOTICE 'OTP for %: %', phone_number, v_otp;\n    \n    -- Return success response\n    v_result := jsonb_build_object(\n        'success', true,\n        'message', 'OTP sent successfully',\n        'expires_in', 300, -- 5 minutes\n        'phone', phone_number\n    );\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "simple_upsert_user_profile",
      "definition": "CREATE OR REPLACE FUNCTION public.simple_upsert_user_profile(p_user_id uuid, p_email text, p_pin text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    result JSONB;\nBEGIN\n    -- Simple approach: try insert, if fails, do update\n    BEGIN\n        INSERT INTO user_profiles (id, email, pin, created_at, updated_at)\n        VALUES (p_user_id, p_email, p_pin, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created',\n            'user_id', p_user_id,\n            'email', p_email\n        );\n    EXCEPTION\n        WHEN unique_violation THEN\n            -- Update existing record\n            UPDATE user_profiles\n            SET \n                email = p_email,\n                pin = COALESCE(p_pin, pin),\n                updated_at = NOW()\n            WHERE id = p_user_id;\n            \n            RETURN jsonb_build_object(\n                'success', true,\n                'is_new_user', false,\n                'message', 'User profile updated',\n                'user_id', p_user_id,\n                'email', p_email\n            );\n        WHEN OTHERS THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'Database error: ' || SQLERRM\n            );\n    END;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "submitindividualtestscore",
      "definition": "CREATE OR REPLACE FUNCTION public.submitindividualtestscore(user_uuid uuid, exam_name text, test_type_name text, test_name text, score_value integer)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_rank INTEGER;\n  v_total_participants INTEGER;\n  v_result JSONB;\nBEGIN\n  -- Calculate rank and total participants properly\n  WITH ranked_scores AS (\n    SELECT \n      user_id,\n      ROW_NUMBER() OVER (ORDER BY score DESC, completed_at ASC) as rank,\n      COUNT(*) OVER () as total_count\n    FROM individual_test_scores \n    WHERE exam_id = exam_name \n      AND test_type = test_type_name \n      AND test_id = test_name\n  )\n  SELECT \n    COALESCE(rs.rank, 1),\n    COALESCE(rs.total_count, 1)\n  INTO v_rank, v_total_participants\n  FROM ranked_scores rs\n  WHERE rs.user_id = user_uuid;\n\n  -- If user doesn't exist in rankings yet, calculate their rank\n  IF v_rank IS NULL THEN\n    SELECT \n      COUNT(*) + 1,\n      COUNT(*) + 1\n    INTO v_rank, v_total_participants\n    FROM individual_test_scores \n    WHERE exam_id = exam_name \n      AND test_type = test_type_name \n      AND test_id = test_name \n      AND score > score_value;\n  END IF;\n\n  -- Insert or update the score\n  INSERT INTO individual_test_scores (\n    user_id, exam_id, test_type, test_id, score, rank, total_participants\n  )\n  VALUES (\n    user_uuid, exam_name, test_type_name, test_name, score_value, v_rank, v_total_participants\n  )\n  ON CONFLICT (user_id, exam_id, test_type, test_id) \n  DO UPDATE SET\n    score = EXCLUDED.score,\n    rank = EXCLUDED.rank,\n    total_participants = EXCLUDED.total_participants,\n    completed_at = now(),\n    updated_at = now();\n\n  -- Recalculate all ranks for this test\n  WITH ranked_scores AS (\n    SELECT \n      user_id,\n      ROW_NUMBER() OVER (ORDER BY score DESC, completed_at ASC) as new_rank,\n      COUNT(*) OVER () as total_count\n    FROM individual_test_scores \n    WHERE exam_id = exam_name \n      AND test_type = test_type_name \n      AND test_id = test_name\n  )\n  UPDATE individual_test_scores \n  SET \n    rank = rs.new_rank,\n    total_participants = rs.total_count,\n    updated_at = now()\n  FROM ranked_scores rs\n  WHERE individual_test_scores.user_id = rs.user_id\n    AND individual_test_scores.exam_id = exam_name \n    AND individual_test_scores.test_type = test_type_name \n    AND individual_test_scores.test_id = test_name;\n\n  -- Return the result\n  SELECT to_jsonb(its.*) INTO v_result\n  FROM individual_test_scores its\n  WHERE its.user_id = user_uuid \n    AND its.exam_id = exam_name \n    AND its.test_type = test_type_name \n    AND its.test_id = test_name;\n  \n  RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_daily_visit",
      "definition": "CREATE OR REPLACE FUNCTION public.update_daily_visit(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Just call update_user_streak\n  RETURN public.update_user_streak(user_uuid);\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_daily_visit_and_streak",
      "definition": "CREATE OR REPLACE FUNCTION public.update_daily_visit_and_streak(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_result JSONB;\n    v_today DATE := CURRENT_DATE;\nBEGIN\n    -- Insert daily visit\n    INSERT INTO public.daily_visits (user_id, visit_date)\n    VALUES (user_uuid, v_today)\n    ON CONFLICT (user_id, visit_date) DO NOTHING;\n    \n    -- Update streak\n    SELECT public.update_user_streak_from_visit(user_uuid) INTO v_result;\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_exam_stats_mock_pyq_only",
      "definition": "CREATE OR REPLACE FUNCTION public.update_exam_stats_mock_pyq_only(exam_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_record RECORD;\n    total_tests INTEGER;\n    best_score INTEGER;\n    average_score INTEGER;\nBEGIN\n    -- Loop through all users who have test completions for this exam\n    FOR user_record IN \n        SELECT DISTINCT user_id \n        FROM public.test_completions \n        WHERE exam_id = exam_name \n            AND test_type IN ('mock', 'pyq')\n    LOOP\n        -- Calculate stats for this user\n        SELECT \n            COUNT(*) as total,\n            MAX(score) as best,\n            ROUND(AVG(score)) as avg\n        INTO total_tests, best_score, average_score\n        FROM public.test_completions\n        WHERE user_id = user_record.user_id\n            AND exam_id = exam_name\n            AND test_type IN ('mock', 'pyq');\n\n        -- Update or insert exam stats\n        INSERT INTO public.exam_stats (user_id, exam_id, total_tests, best_score, average_score, last_test_date)\n        VALUES (user_record.user_id, exam_name, total_tests, best_score, average_score, NOW())\n        ON CONFLICT (user_id, exam_id)\n        DO UPDATE SET\n            total_tests = EXCLUDED.total_tests,\n            best_score = EXCLUDED.best_score,\n            average_score = EXCLUDED.average_score,\n            last_test_date = EXCLUDED.last_test_date,\n            updated_at = NOW();\n    END LOOP;\n\n    -- Recalculate ranks\n    PERFORM public.calculate_exam_ranks(exam_name);\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_exam_stats_properly",
      "definition": "CREATE OR REPLACE FUNCTION public.update_exam_stats_properly(user_uuid uuid, exam_name text, new_score integer)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    existing_stats RECORD;\n    unique_test_count INTEGER;\n    new_best_score INTEGER;\n    new_average_score NUMERIC;\nBEGIN\n    -- Count unique Mock + PYQ test completions for this user and exam\n    SELECT COUNT(DISTINCT CONCAT(test_type, '-', test_id)) INTO unique_test_count\n    FROM test_completions\n    WHERE user_id = user_uuid \n        AND exam_id = exam_name \n        AND test_type IN ('mock', 'pyq');\n    \n    -- Get existing stats\n    SELECT * INTO existing_stats\n    FROM exam_stats\n    WHERE user_id = user_uuid AND exam_id = exam_name;\n    \n    -- Calculate new best score\n    new_best_score := GREATEST(COALESCE(existing_stats.best_score, 0), new_score);\n    \n    -- Calculate new average score based on all Mock + PYQ completions\n    SELECT COALESCE(AVG(score), 0) INTO new_average_score\n    FROM test_completions\n    WHERE user_id = user_uuid \n        AND exam_id = exam_name \n        AND test_type IN ('mock', 'pyq');\n    \n    -- Insert or update exam stats\n    INSERT INTO exam_stats (user_id, exam_id, total_tests, best_score, average_score, last_test_date)\n    VALUES (user_uuid, exam_name, unique_test_count, new_best_score, ROUND(new_average_score), NOW())\n    ON CONFLICT (user_id, exam_id) \n    DO UPDATE SET\n        total_tests = unique_test_count,\n        best_score = new_best_score,\n        average_score = ROUND(new_average_score),\n        last_test_date = NOW(),\n        updated_at = NOW();\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_plan_pricing",
      "definition": "CREATE OR REPLACE FUNCTION public.update_plan_pricing(plan_id text, new_price numeric)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    updated_plan RECORD;\nBEGIN\n    UPDATE public.membership_plans\n    SET price = new_price,\n        updated_at = NOW()\n    WHERE id = plan_id AND is_active = true\n    RETURNING * INTO updated_plan;\n    \n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Plan not found or inactive'\n        );\n    END IF;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'plan_id', updated_plan.id,\n        'new_price', updated_plan.price,\n        'message', 'Plan pricing updated successfully'\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_question_report_status",
      "definition": "CREATE OR REPLACE FUNCTION public.update_question_report_status(p_report_id uuid, p_status text, p_admin_notes text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    result JSONB;\nBEGIN\n    -- For now, allow any authenticated user to update report status\n    -- TODO: Implement proper admin role system later\n    IF auth.uid() IS NULL THEN\n        RETURN jsonb_build_object('success', false, 'error', 'Unauthorized');\n    END IF;\n\n    -- Update the report\n    UPDATE question_reports \n    SET \n        status = p_status,\n        admin_notes = COALESCE(p_admin_notes, admin_notes),\n        resolved_at = CASE \n            WHEN p_status = 'resolved' THEN NOW()\n            ELSE resolved_at\n        END,\n        updated_at = NOW()\n    WHERE id = p_report_id;\n\n    IF FOUND THEN\n        RETURN jsonb_build_object('success', true, 'message', 'Report status updated successfully');\n    ELSE\n        RETURN jsonb_build_object('success', false, 'error', 'Report not found');\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_question_reports_updated_at",
      "definition": "CREATE OR REPLACE FUNCTION public.update_question_reports_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_updated_at_column",
      "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_user_profiles_updated_at",
      "definition": "CREATE OR REPLACE FUNCTION public.update_user_profiles_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_user_streak",
      "definition": "CREATE OR REPLACE FUNCTION public.update_user_streak(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_result JSONB;\n  v_current_streak INTEGER;\n  v_longest_streak INTEGER;\n  v_last_activity_date DATE;\n  v_today DATE;\n  v_days_diff INTEGER;\nBEGIN\n  -- Use UTC date for consistency\n  v_today := CURRENT_DATE AT TIME ZONE 'UTC';\n  \n  -- Get current streak data\n  SELECT \n    us.current_streak,\n    us.longest_streak,\n    us.last_activity_date\n  INTO v_current_streak, v_longest_streak, v_last_activity_date\n  FROM user_streaks us\n  WHERE us.user_id = user_uuid;\n\n  -- If no existing record, create new one\n  IF v_current_streak IS NULL THEN\n    v_current_streak := 1;\n    v_longest_streak := 1;\n    v_last_activity_date := v_today;\n  ELSE\n    -- Calculate days difference\n    v_days_diff := v_today - COALESCE(v_last_activity_date, v_today - 1);\n    \n    -- Update streak based on days difference\n    IF v_days_diff = 0 THEN\n      -- Same day, no change to streak\n      NULL;\n    ELSIF v_days_diff = 1 THEN\n      -- Consecutive day, increment streak\n      v_current_streak := v_current_streak + 1;\n      v_longest_streak := GREATEST(v_longest_streak, v_current_streak);\n      v_last_activity_date := v_today;\n    ELSE\n      -- More than 1 day gap, reset streak\n      v_current_streak := 1;\n      v_longest_streak := GREATEST(v_longest_streak, 1);\n      v_last_activity_date := v_today;\n    END IF;\n  END IF;\n\n  -- Insert or update user streak\n  INSERT INTO user_streaks (\n    user_id, current_streak, longest_streak, total_tests_taken, last_activity_date, created_at, updated_at\n  )\n  VALUES (\n    user_uuid, v_current_streak, v_longest_streak, 1, v_last_activity_date, now(), now()\n  )\n  ON CONFLICT (user_id) \n  DO UPDATE SET\n    current_streak = EXCLUDED.current_streak,\n    longest_streak = EXCLUDED.longest_streak,\n    total_tests_taken = user_streaks.total_tests_taken + 1,\n    last_activity_date = EXCLUDED.last_activity_date,\n    updated_at = now();\n\n  -- Return the updated streak data\n  SELECT \n    json_build_object(\n      'current_streak', v_current_streak,\n      'longest_streak', v_longest_streak,\n      'last_activity_date', v_last_activity_date,\n      'days_diff', v_days_diff\n    )\n  INTO v_result;\n\n  RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "update_user_streak_from_visit",
      "definition": "CREATE OR REPLACE FUNCTION public.update_user_streak_from_visit(user_uuid uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_result JSONB;\n    v_current_streak INTEGER := 0;\n    v_longest_streak INTEGER := 0;\n    v_total_tests INTEGER := 0;\n    v_last_activity_date DATE;\n    v_today DATE := CURRENT_DATE;\n    v_yesterday DATE := CURRENT_DATE - INTERVAL '1 day';\n    v_days_consecutive INTEGER := 0;\nBEGIN\n    -- Get current streak data\n    SELECT \n        current_streak,\n        longest_streak,\n        total_tests_taken,\n        last_activity_date\n    INTO v_current_streak, v_longest_streak, v_total_tests, v_last_activity_date\n    FROM public.user_streaks\n    WHERE user_id = user_uuid;\n\n    -- If no streak record exists, create one\n    IF v_current_streak IS NULL THEN\n        v_current_streak := 1;\n        v_longest_streak := 1;\n        v_total_tests := 1;\n        v_last_activity_date := v_today;\n    ELSE\n        -- Check if user already has activity today\n        IF v_last_activity_date = v_today THEN\n            -- Already counted today, just return current data\n            SELECT to_jsonb(us.*) INTO v_result\n            FROM public.user_streaks us\n            WHERE us.user_id = user_uuid;\n            RETURN v_result;\n        END IF;\n\n        -- Calculate consecutive days from daily_visits table\n        SELECT COUNT(*) INTO v_days_consecutive\n        FROM public.daily_visits\n        WHERE user_id = user_uuid\n        AND visit_date >= v_today - INTERVAL '30 days'  -- Check last 30 days\n        ORDER BY visit_date DESC;\n\n        -- If last activity was yesterday, increment streak\n        IF v_last_activity_date = v_yesterday THEN\n            v_current_streak := v_current_streak + 1;\n        ELSE\n            -- Streak broken, reset to 1\n            v_current_streak := 1;\n        END IF;\n\n        -- Update longest streak if current is higher\n        IF v_current_streak > v_longest_streak THEN\n            v_longest_streak := v_current_streak;\n        END IF;\n\n        v_total_tests := v_total_tests + 1;\n        v_last_activity_date := v_today;\n    END IF;\n\n    -- Insert or update user streak\n    INSERT INTO public.user_streaks (\n        user_id, \n        current_streak, \n        longest_streak, \n        total_tests_taken, \n        last_activity_date\n    )\n    VALUES (\n        user_uuid, \n        v_current_streak, \n        v_longest_streak, \n        v_total_tests, \n        v_last_activity_date\n    )\n    ON CONFLICT (user_id) \n    DO UPDATE SET\n        current_streak = EXCLUDED.current_streak,\n        longest_streak = EXCLUDED.longest_streak,\n        total_tests_taken = EXCLUDED.total_tests_taken,\n        last_activity_date = EXCLUDED.last_activity_date,\n        updated_at = NOW();\n\n    -- Return the result\n    SELECT to_jsonb(us.*) INTO v_result\n    FROM public.user_streaks us\n    WHERE us.user_id = user_uuid;\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "upsert_exam_stats",
      "definition": "CREATE OR REPLACE FUNCTION public.upsert_exam_stats(p_user_id uuid, p_exam_id text, p_total_tests integer DEFAULT 0, p_best_score integer DEFAULT 0, p_average_score integer DEFAULT 0, p_rank integer DEFAULT NULL::integer, p_last_test_date timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    INSERT INTO public.exam_stats (\n        user_id, \n        exam_id, \n        total_tests, \n        best_score, \n        average_score, \n        rank, \n        last_test_date\n    )\n    VALUES (\n        p_user_id, \n        p_exam_id, \n        p_total_tests, \n        p_best_score, \n        p_average_score, \n        p_rank, \n        p_last_test_date\n    )\n    ON CONFLICT (user_id, exam_id)\n    DO UPDATE SET\n        total_tests = EXCLUDED.total_tests,\n        best_score = EXCLUDED.best_score,\n        average_score = EXCLUDED.average_score,\n        rank = EXCLUDED.rank,\n        last_test_date = EXCLUDED.last_test_date,\n        updated_at = NOW();\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "upsert_test_completion",
      "definition": "CREATE OR REPLACE FUNCTION public.upsert_test_completion(p_user_id uuid, p_exam_id text, p_test_type text, p_test_id text, p_topic_id text DEFAULT NULL::text, p_score integer DEFAULT 0, p_total_questions integer DEFAULT 0, p_correct_answers integer DEFAULT 0, p_time_taken integer DEFAULT 0, p_answers jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_result JSONB;\nBEGIN\n  -- Insert or update test completion\n  INSERT INTO test_completions (\n    user_id, exam_id, test_type, test_id, topic_id, \n    score, total_questions, correct_answers, time_taken, answers\n  )\n  VALUES (\n    p_user_id, p_exam_id, p_test_type, p_test_id, p_topic_id,\n    p_score, p_total_questions, p_correct_answers, p_time_taken, p_answers\n  )\n  ON CONFLICT (user_id, exam_id, test_type, test_id, topic_id) \n  DO UPDATE SET\n    score = EXCLUDED.score,\n    total_questions = EXCLUDED.total_questions,\n    correct_answers = EXCLUDED.correct_answers,\n    time_taken = EXCLUDED.time_taken,\n    answers = EXCLUDED.answers,\n    completed_at = now();\n  \n  -- Return the result\n  SELECT to_jsonb(tc.*) INTO v_result\n  FROM test_completions tc\n  WHERE tc.user_id = p_user_id \n    AND tc.exam_id = p_exam_id \n    AND tc.test_type = p_test_type \n    AND tc.test_id = p_test_id \n    AND (tc.topic_id = p_topic_id OR (tc.topic_id IS NULL AND p_topic_id IS NULL));\n  \n  RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "upsert_test_completion_simple",
      "definition": "CREATE OR REPLACE FUNCTION public.upsert_test_completion_simple(p_user_id uuid, p_exam_id text, p_test_type text, p_test_id text, p_topic_id text DEFAULT NULL::text, p_score integer DEFAULT 0, p_total_questions integer DEFAULT 0, p_correct_answers integer DEFAULT 0, p_time_taken integer DEFAULT 0, p_answers jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_result JSONB;\nBEGIN\n  -- Insert or update test completion\n  INSERT INTO test_completions (\n    user_id, exam_id, test_type, test_id, topic_id, \n    score, total_questions, correct_answers, time_taken, answers\n  )\n  VALUES (\n    p_user_id, p_exam_id, p_test_type, p_test_id, p_topic_id,\n    p_score, p_total_questions, p_correct_answers, p_time_taken, p_answers\n  )\n  ON CONFLICT (user_id, exam_id, test_type, test_id, topic_id) \n  DO UPDATE SET\n    score = EXCLUDED.score,\n    total_questions = EXCLUDED.total_questions,\n    correct_answers = EXCLUDED.correct_answers,\n    time_taken = EXCLUDED.time_taken,\n    answers = EXCLUDED.answers,\n    completed_at = now();\n  \n  -- Return the result\n  SELECT to_jsonb(tc.*) INTO v_result\n  FROM test_completions tc\n  WHERE tc.user_id = p_user_id \n    AND tc.exam_id = p_exam_id \n    AND tc.test_type = p_test_type \n    AND tc.test_id = p_test_id \n    AND (tc.topic_id = p_topic_id OR (tc.topic_id IS NULL AND p_topic_id IS NULL));\n  \n  RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "upsert_user_profile_safe",
      "definition": "CREATE OR REPLACE FUNCTION public.upsert_user_profile_safe(p_user_id uuid, p_email text, p_pin text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    result JSONB;\nBEGIN\n    -- Try to insert first\n    BEGIN\n        INSERT INTO user_profiles (id, email, pin, created_at, updated_at)\n        VALUES (p_user_id, p_email, p_pin, NOW(), NOW());\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'is_new_user', true,\n            'message', 'User profile created',\n            'user_id', p_user_id,\n            'email', p_email\n        );\n    EXCEPTION\n        WHEN unique_violation THEN\n            -- If insert fails due to unique constraint, try update\n            BEGIN\n                UPDATE user_profiles\n                SET \n                    email = p_email,\n                    pin = COALESCE(p_pin, pin),\n                    updated_at = NOW()\n                WHERE id = p_user_id;\n                \n                IF FOUND THEN\n                    RETURN jsonb_build_object(\n                        'success', true,\n                        'is_new_user', false,\n                        'message', 'User profile updated',\n                        'user_id', p_user_id,\n                        'email', p_email\n                    );\n                ELSE\n                    -- User doesn't exist, but email is taken by someone else\n                    RETURN jsonb_build_object(\n                        'success', false,\n                        'error', 'Email already in use by another user'\n                    );\n                END IF;\n            EXCEPTION\n                WHEN OTHERS THEN\n                    RETURN jsonb_build_object(\n                        'success', false,\n                        'error', 'Update failed: ' || SQLERRM\n                    );\n            END;\n        WHEN OTHERS THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'Insert failed: ' || SQLERRM\n            );\n    END;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "validate_referral_code",
      "definition": "CREATE OR REPLACE FUNCTION public.validate_referral_code(code_input character varying)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    user_record RECORD;\n    result JSON;\nBEGIN\n    -- Check if code exists and get user info\n    SELECT id, referral_code, total_referrals, max_referrals\n    INTO user_record\n    FROM user_profiles \n    WHERE referral_code = UPPER(code_input);\n    \n    IF user_record IS NULL THEN\n        RETURN json_build_object('valid', false, 'message', 'Invalid referral code');\n    END IF;\n    \n    -- Check if referrer has reached limit\n    IF user_record.total_referrals >= user_record.max_referrals THEN\n        RETURN json_build_object('valid', false, 'message', 'Referrer has reached maximum referrals');\n    END IF;\n    \n    RETURN json_build_object(\n        'valid', true, \n        'message', 'Valid referral code',\n        'referrer_id', user_record.id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "validate_upi_reference",
      "definition": "CREATE OR REPLACE FUNCTION public.validate_upi_reference(p_reference_id text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Check if reference ID is provided\n    IF p_reference_id IS NULL OR TRIM(p_reference_id) = '' THEN\n        RETURN jsonb_build_object(\n            'valid', false,\n            'error', 'Transaction reference is required'\n        );\n    END IF;\n    \n    -- Check minimum length\n    IF LENGTH(TRIM(p_reference_id)) < 8 THEN\n        RETURN jsonb_build_object(\n            'valid', false,\n            'error', 'Transaction reference must be at least 8 characters long'\n        );\n    END IF;\n    \n    -- Check maximum length\n    IF LENGTH(TRIM(p_reference_id)) > 20 THEN\n        RETURN jsonb_build_object(\n            'valid', false,\n            'error', 'Transaction reference must be less than 20 characters'\n        );\n    END IF;\n    \n    -- Check for valid characters (alphanumeric and some special chars)\n    IF NOT p_reference_id ~ '^[A-Za-z0-9_-]+$' THEN\n        RETURN jsonb_build_object(\n            'valid', false,\n            'error', 'Transaction reference contains invalid characters'\n        );\n    END IF;\n    \n    RETURN jsonb_build_object(\n        'valid', true,\n        'error', NULL\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "validate_user_uniqueness",
      "definition": "CREATE OR REPLACE FUNCTION public.validate_user_uniqueness()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Check email uniqueness if email is being set\n    IF NEW.email IS NOT NULL AND NEW.email != '' THEN\n        IF NOT public.check_email_uniqueness(NEW.email) THEN\n            RAISE EXCEPTION 'Email % is already in use by another user', NEW.email;\n        END IF;\n    END IF;\n    \n    -- Check phone uniqueness if phone is being set\n    IF NEW.phone IS NOT NULL AND NEW.phone != '' THEN\n        IF NOT public.check_phone_uniqueness(NEW.phone) THEN\n            RAISE EXCEPTION 'Phone number % is already in use by another user', NEW.phone;\n        END IF;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "verify_otp",
      "definition": "CREATE OR REPLACE FUNCTION public.verify_otp(p_email text, p_otp_code text, p_phone text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    otp_record RECORD;\n    result JSON;\nBEGIN\n    -- Get OTP record\n    SELECT * INTO otp_record\n    FROM public.otp_verifications\n    WHERE email = p_email\n    AND (p_phone IS NULL OR phone = p_phone)\n    AND is_verified = FALSE\n    ORDER BY created_at DESC\n    LIMIT 1;\n    \n    -- Check if OTP exists\n    IF NOT FOUND THEN\n        result := json_build_object(\n            'success', false,\n            'message', 'No valid OTP found for this email'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Check if OTP is expired\n    IF otp_record.expires_at < NOW() THEN\n        result := json_build_object(\n            'success', false,\n            'message', 'OTP has expired. Please request a new one.'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Check if max attempts exceeded\n    IF otp_record.attempts >= otp_record.max_attempts THEN\n        result := json_build_object(\n            'success', false,\n            'message', 'Maximum verification attempts exceeded. Please request a new OTP.'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Check if OTP code matches\n    IF otp_record.otp_code != p_otp_code THEN\n        -- Increment attempts\n        UPDATE public.otp_verifications\n        SET attempts = attempts + 1, updated_at = NOW()\n        WHERE id = otp_record.id;\n        \n        result := json_build_object(\n            'success', false,\n            'message', 'Invalid OTP code. Please try again.'\n        );\n        RETURN result;\n    END IF;\n    \n    -- Mark OTP as verified\n    UPDATE public.otp_verifications\n    SET is_verified = TRUE, updated_at = NOW()\n    WHERE id = otp_record.id;\n    \n    result := json_build_object(\n        'success', true,\n        'message', 'OTP verified successfully',\n        'verification_id', otp_record.id\n    );\n    \n    RETURN result;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "verify_payment",
      "definition": "CREATE OR REPLACE FUNCTION public.verify_payment(p_payment_id uuid, p_razorpay_payment_id text, p_razorpay_signature text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    payment_record RECORD;\n    result JSON;\nBEGIN\n    -- Get payment record\n    SELECT * INTO payment_record \n    FROM public.payments \n    WHERE id = p_payment_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Payment record not found'\n        );\n    END IF;\n    \n    -- Update payment status\n    UPDATE public.payments \n    SET \n        razorpay_payment_id = p_razorpay_payment_id,\n        razorpay_signature = p_razorpay_signature,\n        status = 'paid',\n        paid_at = NOW(),\n        updated_at = NOW()\n    WHERE id = p_payment_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'payment_id', p_payment_id,\n        'user_id', payment_record.user_id,\n        'plan_id', payment_record.plan_id\n    );\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "verify_payment",
      "definition": "CREATE OR REPLACE FUNCTION public.verify_payment(p_payment_id text, p_reference_id text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    payment_record RECORD;\n    verification_count INTEGER;\n    existing_verification RECORD;\n    validation_result JSONB;\nBEGIN\n    -- Check if payment exists and is in paid status\n    SELECT * INTO payment_record\n    FROM public.payments\n    WHERE payment_id = p_payment_id \n        AND status = 'paid'\n        AND expires_at > NOW();\n    \n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment not found, not paid, or expired'\n        );\n    END IF;\n    \n    -- Check if already verified\n    IF payment_record.verification_status = 'verified' THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment already verified'\n        );\n    END IF;\n    \n    -- Check verification attempts (max 5)\n    SELECT COUNT(*) INTO verification_count\n    FROM public.payment_verifications\n    WHERE payment_id = payment_record.id;\n    \n    IF verification_count >= 5 THEN\n        -- Mark as disputed after max attempts\n        UPDATE public.payments\n        SET status = 'disputed',\n            verification_status = 'disputed',\n            dispute_reason = 'Maximum verification attempts exceeded'\n        WHERE id = payment_record.id;\n        \n        INSERT INTO public.payment_audit_log (\n            payment_id, action, old_status, new_status, reason\n        ) VALUES (\n            payment_record.id, 'disputed', 'paid', 'disputed', 'Maximum verification attempts exceeded'\n        );\n        \n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Maximum verification attempts exceeded. Payment marked for manual review.'\n        );\n    END IF;\n    \n    -- Validate reference ID format\n    validation_result := validate_upi_reference(p_reference_id);\n    IF (validation_result->>'valid')::boolean = false THEN\n        -- Record failed verification\n        INSERT INTO public.payment_verifications (\n            payment_id, reference_id, verification_attempt, status, failed_reason\n        ) VALUES (\n            payment_record.id, p_reference_id, verification_count + 1, 'failed', validation_result->>'error'\n        );\n        \n        RETURN jsonb_build_object(\n            'success', false,\n            'error', validation_result->>'error'\n        );\n    END IF;\n    \n    -- Check for duplicate reference ID\n    SELECT * INTO existing_verification\n    FROM public.payment_verifications\n    WHERE reference_id = p_reference_id AND status = 'verified';\n    \n    IF FOUND THEN\n        -- Record failed verification\n        INSERT INTO public.payment_verifications (\n            payment_id, reference_id, verification_attempt, status, failed_reason\n        ) VALUES (\n            payment_record.id, p_reference_id, verification_count + 1, 'failed', 'Reference ID already used'\n        );\n        \n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'This transaction reference has already been used'\n        );\n    END IF;\n    \n    -- Simulate verification (replace with actual payment gateway verification)\n    -- In production, you would call your payment gateway API here\n    IF perform_payment_verification(payment_record, p_reference_id) THEN\n        -- Mark payment as verified\n        UPDATE public.payments\n        SET status = 'verified',\n            verification_status = 'verified',\n            verified_at = NOW()\n        WHERE id = payment_record.id;\n        \n        -- Record successful verification\n        INSERT INTO public.payment_verifications (\n            payment_id, reference_id, verification_attempt, status, verification_method, verified_at\n        ) VALUES (\n            payment_record.id, p_reference_id, verification_count + 1, 'verified', 'manual', NOW()\n        );\n        \n        -- Activate user membership\n        UPDATE public.user_profiles\n        SET membership_plan = payment_record.plan_id,\n            membership_expiry = CASE \n                WHEN payment_record.plan_id = 'monthly' THEN NOW() + INTERVAL '1 month'\n                WHEN payment_record.plan_id = 'yearly' THEN NOW() + INTERVAL '1 year'\n                WHEN payment_record.plan_id = 'lifetime' THEN NOW() + INTERVAL '100 years'\n                ELSE NOW() + INTERVAL '1 month'\n            END,\n            updated_at = NOW()\n        WHERE id = payment_record.user_id;\n        \n        -- Log successful verification\n        INSERT INTO public.payment_audit_log (\n            payment_id, action, old_status, new_status, reason\n        ) VALUES (\n            payment_record.id, 'verified', 'paid', 'verified', 'Payment verified successfully'\n        );\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'message', 'Payment verified successfully',\n            'payment_id', payment_record.payment_id,\n            'plan_name', payment_record.plan_name,\n            'membership_activated', true\n        );\n    ELSE\n        -- Record failed verification\n        INSERT INTO public.payment_verifications (\n            payment_id, reference_id, verification_attempt, status, failed_reason\n        ) VALUES (\n            payment_record.id, p_reference_id, verification_count + 1, 'failed', 'Payment verification failed'\n        );\n        \n        RETURN jsonb_build_object(\n            'success', false,\n            'error', 'Payment verification failed. Please check your transaction reference and try again.'\n        );\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "public",
      "function_name": "verify_phone_otp",
      "definition": "CREATE OR REPLACE FUNCTION public.verify_phone_otp(user_uuid uuid, phone_number character varying, otp_code character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    v_verification RECORD;\n    v_result JSONB;\nBEGIN\n    -- Find the OTP record\n    SELECT * INTO v_verification\n    FROM public.phone_verifications\n    WHERE user_id = user_uuid \n    AND phone = phone_number \n    AND otp_code = otp_code\n    AND expires_at > NOW()\n    AND verified = FALSE;\n    \n    -- Check if OTP is valid\n    IF v_verification IS NULL THEN\n        v_result := jsonb_build_object(\n            'success', false,\n            'message', 'Invalid or expired OTP'\n        );\n        RETURN v_result;\n    END IF;\n    \n    -- Mark OTP as verified\n    UPDATE public.phone_verifications\n    SET verified = TRUE, updated_at = NOW()\n    WHERE id = v_verification.id;\n    \n    -- Update user profile with verified phone\n    UPDATE public.user_profiles\n    SET \n        phone = phone_number,\n        phone_verified = TRUE,\n        updated_at = NOW()\n    WHERE id = user_uuid;\n    \n    -- Return success response\n    v_result := jsonb_build_object(\n        'success', true,\n        'message', 'Phone number verified successfully'\n    );\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "apply_rls",
      "definition": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "broadcast_changes",
      "definition": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "build_prepared_statement_sql",
      "definition": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "cast",
      "definition": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "check_equality_op",
      "definition": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "is_visible_through_filters",
      "definition": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "list_changes",
      "definition": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "quote_wal2json",
      "definition": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "send",
      "definition": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "subscription_check_filters",
      "definition": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "to_regrole",
      "definition": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
    },
    {
      "schema": "realtime",
      "function_name": "topic",
      "definition": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "add_prefixes",
      "definition": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "can_insert_object",
      "definition": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "delete_prefix",
      "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "delete_prefix_hierarchy_trigger",
      "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "enforce_bucket_name_length",
      "definition": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "extension",
      "definition": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "filename",
      "definition": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "foldername",
      "definition": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "get_level",
      "definition": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "get_prefix",
      "definition": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "get_prefixes",
      "definition": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "get_size_by_bucket",
      "definition": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "list_multipart_uploads_with_delimiter",
      "definition": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "list_objects_with_delimiter",
      "definition": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "objects_insert_prefix_trigger",
      "definition": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "objects_update_prefix_trigger",
      "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "operation",
      "definition": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "prefixes_insert_trigger",
      "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "search",
      "definition": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "search_legacy_v1",
      "definition": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "search_v1_optimised",
      "definition": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "search_v2",
      "definition": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN query EXECUTE\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name || '/' AS name,\n                    NULL::uuid AS id,\n                    NULL::timestamptz AS updated_at,\n                    NULL::timestamptz AS created_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n                ORDER BY prefixes.name COLLATE \"C\" LIMIT $3\n            )\n            UNION ALL\n            (SELECT split_part(name, '/', $4) AS key,\n                name,\n                id,\n                updated_at,\n                created_at,\n                metadata\n            FROM storage.objects\n            WHERE name COLLATE \"C\" LIKE $1 || '%'\n                AND bucket_id = $2\n                AND level = $4\n                AND name COLLATE \"C\" > $5\n            ORDER BY name COLLATE \"C\" LIMIT $3)\n        ) obj\n        ORDER BY name COLLATE \"C\" LIMIT $3;\n        $sql$\n        USING prefix, bucket_name, limits, levels, start_after;\nEND;\n$function$\n"
    },
    {
      "schema": "storage",
      "function_name": "update_updated_at_column",
      "definition": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
    },
    {
      "schema": "vault",
      "function_name": "_crypto_aead_det_decrypt",
      "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
    },
    {
      "schema": "vault",
      "function_name": "_crypto_aead_det_encrypt",
      "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
    },
    {
      "schema": "vault",
      "function_name": "_crypto_aead_det_noncegen",
      "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
    },
    {
      "schema": "vault",
      "function_name": "create_secret",
      "definition": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
    },
    {
      "schema": "vault",
      "function_name": "update_secret",
      "definition": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
    }
  ]